<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX3231FABC38FD4F98AD31EE2913CC45E5">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>-1.29999995</Y>
				<Z>-0.25</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">TinyPonyStampede</string>
			<bool name="RequiresHandle">true</bool>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=254918365</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX2AD08B5BF2384DC6A19AF942E6D49913">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-12.8811455</X>
					<Y>4.04463243</Y>
					<Z>-66.573082</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.5</X>
					<Y>1.75</Y>
					<Z>2.5</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX0B6878CA53C7481291B38724BEBE298F">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=254917644</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.5</X>
						<Y>0.5</Y>
						<Z>0.5</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=254918451</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX51C913914DCE47058AAAC773694156BB">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">true</bool>
					<string name="Name">Earthquake</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=255284510</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX8A881D1260F24DFEBFBBA45FC7A3BD0A">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">true</bool>
					<string name="Name">Gallop</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=255284524</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXB748DA02E05A434E9A2CB46E98155D1F">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Scream</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=25697118</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">1</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX995B2A49DE164F4CAB96904C16560ECB">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<string name="ScriptGuid">{3F9FD084-1126-404D-B50A-35D6B2B6C33E}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer
--Updated for R15 avatar by StarWars

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

BaseUrl = "http://www.roblox.com/asset/?id="

ServerControl = Tool:WaitForChild("ServerControl")
ClientControl = Tool:WaitForChild("ClientControl")

InputCheck = Create("ScreenGui"){
	Name = "InputCheck",
	Create("ImageButton"){
		Name = "InputButton",
		Image = "",
		BackgroundTransparency = 1,
		ImageTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Parent = InputCheck,
	}
}

BasePart = Create("Part"){
	Shape = Enum.PartType.Block,
	Material = Enum.Material.Plastic,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	FormFactor = Enum.FormFactor.Custom,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
	Anchored = false,
}

Arrow = BasePart:Clone()
Arrow.Name = "Arrow"
Arrow.BrickColor = BrickColor.new("Lime green")
Arrow.Size = Vector3.new(1, 0.25, 1)
Arrow.CanCollide = false
Arrow.Anchored = true
ArrowMesh = Create("SpecialMesh"){
	Name = "Mesh",
	MeshType = Enum.MeshType.FileMesh,
	MeshId = (BaseUrl .. "14656345"),
	TextureId = (BaseUrl .. "109635220"),
	Scale = Vector3.new(0.05, 0.1, 0.03),
	VertexColor = Vector3.new(1, 1, 1),
	Offset = Vector3.new(0, 0, 0),
	Parent = Arrow,
}

Rate = (1 / 60)

MouseDown = false
ToolEquipped = false

function Clamp(Number, Min, Max)
	return math.max(math.min(Max, Number), Min)
end

function GetPercentage(Start, End, Number)
	return (((Number - Start) / (End - Start)) * 100)
end

function Round(Number, RoundDecimal)
	local WholeNumber, Decimal = math.modf(Number)
	return ((Decimal >= RoundDecimal and math.ceil(Number)) or (Decimal < RoundDecimal and math.floor(Number)))
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end

function MouseClick(Down)
	if Down and not MouseDown and Tool.Enabled then
		if not PlayerMouse.Target then
			return
		end
		local StartPoint = PlayerMouse.Hit.p
		if (Handle.Position - StartPoint).magnitude > 50 then
			return
		end
		MouseDown = true
		Spawn(function()
			local Camera = game:GetService("Workspace").CurrentCamera
			local DisplayArrow, Direction
			while MouseDown and ToolEquipped and CheckIfAlive() do
				local CurrentPoint = PlayerMouse.Hit.p
				local DistanceCap = {Min = 15, Max = 100}
				local OriginalDistance = (StartPoint - CurrentPoint).magnitude
				local Distance = Clamp(OriginalDistance, DistanceCap.Min, DistanceCap.Max)
				if OriginalDistance >= DistanceCap.Min then
					if not DisplayArrow or not DisplayArrow.Parent then
						DisplayArrow = Arrow:Clone()
						Debris:AddItem(DisplayArrow, 15)
						DisplayArrow.Parent = Camera
					end
					local DistancePercent = GetPercentage(DistanceCap.Min, DistanceCap.Max, Distance)
					local Color = {
						R = Clamp((1 * DistancePercent / 100), 0, 1),
						G = Clamp(((DistancePercent < 100 and (2 / DistancePercent * 100)) or 0), 0, 1),
						B = 0,
					}
					DisplayArrow.Mesh.VertexColor = Vector3.new(Color.R, Color.G, Color.B)
					Direction = CFrame.new(StartPoint, Vector3.new(CurrentPoint.X, StartPoint.Y, CurrentPoint.Z))
					local OriginPoint = (CFrame.new(StartPoint) + Direction.lookVector * (Distance / 2))
					DisplayArrow.CFrame = CFrame.new(OriginPoint.p, Vector3.new(CurrentPoint.X, OriginPoint.p.Y, CurrentPoint.Z))
					DisplayArrow.Mesh.Scale = Vector3.new((15 * Arrow.Mesh.Scale.X), Arrow.Mesh.Scale.Y, (Distance * Arrow.Mesh.Scale.Z))
				else
					if DisplayArrow and DisplayArrow.Parent then
						DisplayArrow.Parent = nil
						Direction = nil
					end
				end
				wait(Rate)
			end
			if DisplayArrow and DisplayArrow.Parent then
				DisplayArrow:Destroy()
			end
			if not ToolEquipped or not CheckIfAlive() then
				return
			end
			if not StartPoint or not Direction then
				StartPoint = (Torso.CFrame * CFrame.new(8, 0, 0)).p
				Direction = Torso.CFrame
			end
			InvokeServer("SpawnStampede", {SpawnPoint = StartPoint, Direction = Direction})
			MouseDown = false
		end)
	elseif not Down and MouseDown then
		MouseDown = false
	end
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	ToolEquipped = true
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		PlayerMouse = Player:GetMouse()
		Mouse.Button1Down:connect(function()
			MouseClick(true)
		end)
		Mouse.Button1Up:connect(function()
			MouseClick(false)
		end)
		local PlayerGui = Player:FindFirstChild("PlayerGui")
		if PlayerGui then
			if UserInputService.TouchEnabled then
				InputCheckClone = InputCheck:Clone()
				InputCheckClone.InputButton.InputBegan:connect(function()
					MouseClick(true)
				end)
				InputCheckClone.InputButton.InputEnded:connect(function()
					MouseClick(false)
				end)
				InputCheckClone.Parent = PlayerGui
			end
		end
	end)
end

function Unequipped()
	if InputCheckClone and InputCheckClone.Parent then
		InputCheckClone:Destroy()
	end
	MouseDown = false
	ToolEquipped = false
end

function InvokeServer(mode, value)
	pcall(function()
		local ServerReturn = ServerControl:InvokeServer(mode, value)
		return ServerReturn
	end)
end

function OnClientInvoke(mode, value)
	if not ToolEquipped or not CheckIfAlive() or not value then
		return
	end
	if mode == "PlaySound" and value then
		value:Play()
	elseif mode == "StopSound" and value then
		value:Stop()
	elseif mode == "MousePosition" then
		return {Position = PlayerMouse.Hit.p, Target = PlayerMouse.Target}
	end
end

ClientControl.OnClientInvoke = OnClientInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBXA009803293EC43CE8EB55AAD4B4C584D">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

function OnChanged(Property)
	if Property == "Enabled" then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXF1620D97743A46609BC1BA4A39ABFFE9">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script</string>
				<string name="ScriptGuid">{E4628197-6DF3-4FE9-8627-09D5BDBF881B}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer
--Updated for R15 avatar by StarWars

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
InsertService = game:GetService("InsertService")

PonyModel = InsertService:LoadAsset(255278956)
Pony = PonyModel:GetChildren()[1]:Clone()
Debris:AddItem(PonyModel, 1)

AIScript = script:WaitForChild("AIScript")
Remover = script:WaitForChild("Remover")

BaseUrl = "http://www.roblox.com/asset/?id="

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

Sounds = {
	Earthquake = Handle:WaitForChild("Earthquake"),
	Gallop = Handle:WaitForChild("Gallop"),
	Scream = Handle:WaitForChild("Scream"),
}

BasePart = Create("Part"){
	Shape = Enum.PartType.Block,
	Material = Enum.Material.Plastic,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	FormFactor = Enum.FormFactor.Custom,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
	Anchored = false,
}

ReloadTime = 15

Rate = (1 / 60)

ToolEquipped = false

ServerControl = (Tool:FindFirstChild("ServerControl") or Create("RemoteFunction"){
	Name = "ServerControl",
	Parent = Tool,
})

ClientControl = (Tool:FindFirstChild("ClientControl") or Create("RemoteFunction"){
	Name = "ClientControl",
	Parent = Tool,
})

Handle.Transparency = 0
Tool.Enabled = true

function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end

function CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Laser", "Bullet"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end

function CastRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end

function Activated()
	if not Tool.Enabled or not ToolEquipped or not CheckIfAlive() then
		return
	end
end

function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0) and true) or false)
end

function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
end

function Unequipped()
	ToolEquipped = false
end

function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end

ServerControl.OnServerInvoke = (function(player, Mode, Value)
	if player ~= Player or not ToolEquipped or not CheckIfAlive() or not Mode or not Value or not Tool.Enabled then
		return
	end
	if Mode == "SpawnStampede" then
		local ToolName = "TinyPonyStampede"
		local ModelName = (Player.Name .. "'s" .. ToolName)
		local PonyModel = game:GetService("Workspace"):FindFirstChild(ModelName)
		if PonyModel then
			return
		end
		local SpawnPoint = Value.SpawnPoint
		local Direction = Value.Direction
		local DistanceBetween = (Handle.Position - SpawnPoint).magnitude
		if not SpawnPoint or not Direction or DistanceBetween > 50 then
			return
		end
		local AreaBelow, AreaPos, AreaNormal = CastRay((CFrame.new(SpawnPoint) * CFrame.new(0, 2, 0)).p, Vector3.new(0, -1, 0), 6, {Character}, false)
		if not AreaBelow then
			return
		end
		Tool.Enabled = false
		PonyModel = Create("Model"){
			Name = ModelName,
		}
		local Values = {
			{Name = "Creator", Class = "ObjectValue", Value = Player},
			{Name = "Tool", Class = "ObjectValue", Value = Tool},
		}
		for i, v in pairs(Values) do
			local Value = Instance.new(v.Class)
			Value.Name = v.Name
			Value.Value = v.Value
			Value.Parent = PonyModel
		end
		for i, v in pairs({AIScript, Remover}) do
			local ScriptClone = v:Clone()
			ScriptClone.Disabled = false
			ScriptClone.Parent = PonyModel
		end
		local PonySize = Pony:GetModelSize()
		local TotalPonies = 12
		local Ponies = {}
		for x = 1, 2 do
			for z = 1, (TotalPonies / 2) do
				local PonyCopy = Pony:Clone()
				local PonyHumanoid = PonyCopy:FindFirstChild("Humanoid")
				local PonyTorso = PonyCopy:FindFirstChild("Torso")
				for i, v in pairs({Sounds.Scream, Sounds.Gallop, Sounds.Earthquake}) do
					local Sound = v:Clone()
					Sound.Parent = PonyTorso
				end
				local Values = {
					{Name = "Creator", Class = "ObjectValue", Value = Player},
					{Name = "Mode", Class = "StringValue", Value = "Follow"},
					{Name = "MaxDistance", Class = "NumberValue", Value = 300},
					{Name = "Follow", Class = "ObjectValue", Value = Player},
					{Name = "Offset", Class = "Vector3Value", Value = Vector3.new(-3, 0, -0.5)},
					{Name = "Target", Class = "ObjectValue", Value = nil},
					{Name = "TargetPos", Class = "Vector3Value", Value = Vector3.new(0, 0, 0)},
					{Name = "Damage", Class = "NumberValue", Value = 15},
				}
				for i, v in pairs(Values) do
					local Value = Instance.new(v.Class)
					Value.Name = v.Name
					Value.Value = v.Value
					Value.Parent = PonyCopy
				end
				local PonyStart = (CFrame.new(AreaPos, (CFrame.new(AreaPos) + Direction.lookVector * 2).p) * CFrame.new((PonySize.X + 0.5) * ((x == 1 and -1) or 1), (PonySize.Y / 2), (-(PonySize.Z * (TotalPonies / 2)) + (((PonySize.Z / 2) + 2) * z))))
				local BodyGyro = Create("BodyGyro"){
					maxTorque = Vector3.new(math.huge, math.huge, math.huge),
					cframe = Direction,
					Parent = PonyTorso,
				}
				if PonyHumanoid and PonyHumanoid.Health > 0 and PonyTorso then
					PonyHumanoid.WalkSpeed = (16 * 4)
					PonyHumanoid.MaxHealth = 200
					PonyHumanoid.Health = PonyHumanoid.MaxHealth
					PonyTorso.CFrame = PonyStart
					PonyCopy.Parent = PonyModel
				end
				table.insert(Ponies, PonyCopy)
			end
		end
		for i, v in pairs(Ponies) do
			v.Mode.Value = "MoveTo"
			v.TargetPos.Value = (v.Torso.CFrame + v.Torso.CFrame.lookVector * 1e+5).p
		end
		Debris:AddItem(PonyModel, (60 / 2))
		PonyModel.Parent = game:GetService("Workspace")
		for i, v in pairs(Ponies) do
			local torso = v:FindFirstChild("Torso")
			if torso then
				for ii, vv in pairs(torso:GetChildren()) do
					if vv:IsA("Sound") then
						vv:Play()
					end
				end
			end
		end
		wait(ReloadTime)
		Tool.Enabled = true
	end
end)

Tool.Changed:connect(function(Property)
	Handle.Transparency = (((Tool.Parent:IsA("Backpack") or Players:GetPlayerFromCharacter(Tool.Parent) and ((Tool.Enabled and 0) or 1)) or 0))
end)

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX62642A202773421698B814886059E8B6">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Remover</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Model = script.Parent
Humanoid = Model:FindFirstChild("Humanoid")

Players = game:GetService("Players")
Debris = game:GetService("Debris")

Creator = Model:FindFirstChild("Creator")
Tool = Model:FindFirstChild("Tool")

function DestroyModel()
	Debris:AddItem(Model, 2)
end

if not Creator or not Creator.Value or not Creator.Value:IsA("Player") or not Creator.Value.Parent or not Tool or not Tool.Value or not Tool.Value.Parent then
	DestroyModel()
	return
end

Creator = Creator.Value
Tool = Tool.Value

Character = Creator.Character
if not Character then
	DestroyModel()
	return
end

Creator.Changed:connect(function(Property)
	if Property == "Parent" and not Creator.Parent then
		DestroyModel()
	end
end)

Character.Changed:connect(function(Property)
	if Property == "Parent" and not Character.Parent then
		DestroyModel()
	end
end)

Tool.Changed:connect(function(Property)
	if Property == "Parent" then
		local Player = ((Tool.Parent and ((Tool.Parent:IsA("Backpack") and Tool.Parent.Parent) or Players:GetPlayerFromCharacter(Tool.Parent))) or nil)
		if (not Player or (Player and Player ~= Creator)) then
			DestroyModel()
		end
	end
end)

if Humanoid then
	Humanoid.Died:connect(function()
		DestroyModel()
	end)
end]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX3A68C79223AF44B691D02943FAD7C78B">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AIScript</string>
					<string name="ScriptGuid">{562D085F-4614-4269-92B5-1B1026A12476}</string>
					<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer
--Updated for R15 avatar by StarWars

Model = script.Parent

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

TripScript = script:WaitForChild("TripScript")

Functions = require(script:WaitForChild("Functions"))

LastMove = 0

BasePart = Instance.new("Part")
BasePart.Shape = Enum.PartType.Block
BasePart.Material = Enum.Material.Plastic
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.CanCollide = true
BasePart.Locked = true
BasePart.Anchored = false

Figures = {}

function IncludeFigure(Child)
	if not Child or not Child.Parent then
		return
	end
	local Player = Players:GetPlayerFromCharacter(Child)
	if Player then
		return
	end
	for i, v in pairs(Figures) do
		if v.Figure == Child then
			return
		end
	end
	local Figure = {Figure = Child, TouchDebounce = false, Connections = {}}
	local Humanoid = Child:FindFirstChild("Humanoid")
	local Head = Child:FindFirstChild("Head")
	local Torso = Child:FindFirstChild("Torso")
	if not Humanoid or not Humanoid:IsA("Humanoid") or Humanoid.Health == 0 or not Head or not Torso then
		return
	end
	local Neck = Torso:FindFirstChild("Neck")
	if not Neck then
		return
	end
	for i, v in pairs({Humanoid, Head, Torso, Neck}) do
		Figure[v.Name] = v
	end
	local Values = {"Creator", "Mode", "Follow", "Target", "TargetPos", "Offset", "Damage", "MaxDistance"}
	for i, v in pairs(Values) do
		local Value = Child:FindFirstChild(v)
		if not Value then
			return
		end
		Figure[v] = Value
	end
	local HumanoidChanged = Humanoid.Changed:connect(function(Property)
		if Property == "Sit" and Humanoid.Sit then
			Humanoid.Sit = false
			Humanoid.Jump = true
		end
	end)
	local HumanoidDied = Humanoid.Died:connect(function()
		Debris:AddItem(Child, 2)
	end)
	local FigureRemoved = Child.Changed:connect(function(Property)
		if Property == "Parent" and not Child.Parent then
			for i, v in pairs(Figures) do
				if v == Figure then
					for ii, vv in pairs(v.Connections) do
						if vv then
							vv:disconnect()
						end
					end
					table.remove(Figures, i)
					if #Figures == 0 then
						Debris:AddItem(Model, 2)
					end
				end
			end
		end
	end)
	for i ,v in pairs({HumanoidChanged, HumanoidDied, FigureRemoved}) do
		table.insert(Figure.Connections, v)
	end
	for i, v in pairs(Child:GetChildren()) do
		if v:IsA("BasePart") then
			local TouchedConnection
			TouchedConnection = v.Touched:connect(function(Hit)
				if not Hit or not Hit.Parent or Figure.TouchDebounce then
					return
				end
				local Connected = false
				local ConnectedParts = v:GetConnectedParts()
				if #ConnectedParts <= 1 then
					return
				end
				for i, v in pairs(ConnectedParts) do
					if v == Torso then
						Connected = true
					end
				end
				if not Connected then
					return
				end
				local character = Hit.Parent
				if character:IsA("Hat") then
					character = character.Parent
				end
				--[[if character ~= Figure.Target.Value then
					return
				end]]
				local player = Players:GetPlayerFromCharacter(character)
				local CreatorValue = Figure.Creator.Value
				if not CreatorValue then
					return
				end
				local CreatorPlayer = ((CreatorValue:IsA("Player") and CreatorValue) or Players:GetPlayerFromCharacter(CreatorValue))
				if player then
					if player == CreatorPlayer then
						return
					end
					if player and CreatorPlayer and Functions.IsTeamMate(CreatorPlayer, player) then
						return
					end
				end
				local creator = character:FindFirstChild("Creator")
				if creator and creator:IsA("ObjectValue") and creator.Value == CreatorValue then
					return
				end
				local humanoid = character:FindFirstChild("Humanoid")
				if not humanoid or not humanoid:IsA("Humanoid") or humanoid.Health == 0 then
					return
				end
				if player then
					local TripScriptClone = TripScript:Clone()
					local Duration = Instance.new("NumberValue")
					Duration.Name = "Duration"
					Duration.Value = 2
					Duration.Parent = TripScriptClone
					TripScriptClone.Disabled = false
					Debris:AddItem(TripScriptClone, 4)
					TripScriptClone.Parent = character
				end
				Figure.TouchDebounce = true
				Functions.UntagHumanoid(humanoid)
				Functions.TagHumanoid(humanoid, CreatorPlayer)
				humanoid:TakeDamage(Figure.Damage.Value)
				wait(0.125)
				Figure.TouchDebounce = false
			end)
			table.insert(Figure.Connections, TouchedConnection)
		end
	end
	table.insert(Figures, Figure)
end

function SecureJump(Table)
	local Humanoid = Table.Humanoid
	local Torso = Table.Torso
	if not Humanoid or Humanoid.Jump or not Torso then
		return
	end
	local TargetPoint = Torso.Velocity.Unit
	local Blockage, BlockagePos = Functions.CastRay((Torso.CFrame + CFrame.new(Torso.Position, Vector3.new(TargetPoint.X, Torso.Position.Y, TargetPoint.Z)).lookVector * (Torso.Size.Z / 2)).p, Torso.CFrame.lookVector, (Torso.Size.Z * 2.5), {Figure, (((Creator and Creator.Value and Creator.Value:IsA("Player") and Creator.Value.Character) and Creator.Value.Character) or nil)}, false)
	local Jumpable = false
	if Blockage then
		Jumpable = true
		if Blockage:IsA("Terrain") then
			local CellPos = Blockage:WorldToCellPreferSolid((BlockagePos - Vector3.new(0, 2, 0)))
			local CellMaterial, CellShape, CellOrientation = Blockage:GetCell(CellPos.X, CellPos.Y, CellPos.Z)
			if CellMaterial == Enum.CellMaterial.Water then
				Jumpable = false
			end
		elseif Blockage.Parent:FindFirstChild("Humanoid") then
			Jumpable = false
		end
	end
	if Jumpable then
		Humanoid.Jump = true
	end
end

RunService.Stepped:connect(function()
	_, Time = wait(0.05)
	for i, v in pairs(Figures) do
		Spawn(function()
			pcall(function()
				if v and v.Figure and v.Figure.Parent then
					Spawn(function()
						SecureJump(v)
					end)
					local Disabled = v.Figure:FindFirstChild("Disabled")
					if not Disabled then
						local CreatorValue = v.Creator.Value
						if CreatorValue then
							local CreatorPlayer = ((CreatorValue:IsA("Player") and CreatorValue) or Players:GetPlayerFromCharacter(v.Creator.Value))
							if CreatorPlayer then
								local CreatorCharacter = CreatorPlayer.Character
								if CreatorCharacter and CreatorCharacter.Parent then
									local CreatorTorso = CreatorCharacter:FindFirstChild("Torso") or CreatorCharacter:FindFirstChild("UpperTorso")
									if CreatorTorso then
										local DistanceApart = (CreatorTorso.Position - v.Torso.Position).magnitude
										if DistanceApart > v.MaxDistance.Value then
											v.Figure:Destroy()
											--v.Mode.Value = "Follow"
										end
									end
								end
							end
						end
						if v.Mode.Value == "Follow" then
							local FollowValue = v.Follow.Value
							if FollowValue then
								if FollowValue:IsA("Player") and FollowValue.Character and FollowValue.Character.Parent then
									FollowValue = FollowValue.Character
								end
								local FollowHumanoid = FollowValue:FindFirstChild("Humanoid")
								local FollowTorso = FollowValue:FindFirstChild("Torso") or FollowValue:FindFirstChild("UpperTorso")
								if FollowHumanoid and FollowHumanoid.Health > 0 and FollowTorso then
									--if (v.Torso.Position - FollowTorso.Position).magnitude > 5 then
										v.Humanoid:MoveTo((FollowTorso.CFrame * CFrame.new(v.Offset.Value)).p)
									--end
								end
							end
						elseif v.Mode.Value == "MoveTo" then
							v.Humanoid:MoveTo(v.TargetPos.Value)
							LastMove = Time
							--v.Mode.Value = "Nothing"
						elseif v.Mode.Value == "Attack" then
							local TargetCharacter = v.Target.Value
							local TargetDisabled = v.Target:FindFirstChild("Disabled")
							local NotFound = false
							if not TargetDisabled or not TargetDisabled.Value then
								if TargetCharacter and TargetCharacter.Parent then
									local TargetHumanoid = TargetCharacter:FindFirstChild("Humanoid")
									local TargetTorso = TargetCharacter:FindFirstChild("Torso") or TargetCharacter:FindFirstChild("UpperTorso")
									local creator = TargetCharacter:FindFirstChild("Creator")
									if TargetHumanoid and TargetHumanoid.Health > 0 and TargetTorso and (not creator or (creator and v.Creator.Value ~= creator.Value and not Functions.IsTeamMate(v.Creator.Value, creator.Value))) then
										local ChaseOffset = Vector3.new(((math.random() - 0.5) * 5), ((math.random() - 0.5) * 5), ((math.random() - 0.5) * 5))
										v.Humanoid:MoveTo((TargetTorso.CFrame * CFrame.new(ChaseOffset)).p)
									else
										NotFound = true
									end
								else
									NotFound = true
								end
							end
							if NotFound then
								v.Target.Value = nil
								v.Mode.Value = "Follow"
							end
						elseif v.Mode.Value == "Nothing" then
							if (Time - LastMove) >= 30 then
								v.Mode.Value = "Follow"
							end
						end
					end
				end
			end)
		end)
	end
end)

for i, v in pairs(Model:GetChildren()) do
	IncludeFigure(v)
end

Model.ChildAdded:connect(function(Child)
	IncludeFigure(Child)
end)]]></ProtectedString>
				</Properties>
				<Item class="ModuleScript" referent="RBXAD62C54236A24A2FBE7AA3F2E697444C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Functions</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Players = game:GetService("Players")
Debris = game:GetService("Debris")

ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Laser", "Ray", "Bullet", "ParticlePart"}

Functions = {
	
	CheckTableForString = (function(Table, String)
		for i, v in pairs(Table) do
			if string.lower(v) == string.lower(String) then
				return true
			end
		end
		return false
	end),

	CheckIntangible = (function(Hit)
		if Hit and Hit.Parent then
			if (Hit.Transparency >= 1 and not Hit.CanCollide) or Functions.CheckTableForString(ProjectileNames, Hit.Name) then
				return true
			end
			local ObjectParent = Hit.Parent
			local Character = ObjectParent.Parent
			local Humanoid = Character:FindFirstChild("Humanoid")
			if Humanoid and Humanoid.Health > 0 and ObjectParent:IsA("Hat") then
				return true
			end
		end
		return false
	end),
	
	CastRay = (function(StartPos, Vec, Length, Ignore, DelayIfHit)
		local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
		if RayHit and Functions.CheckIntangible(RayHit) then
			if DelayIfHit then
				wait()
			end
			RayHit, RayPos, RayNormal = Functions.CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
		end
		return RayHit, RayPos, RayNormal
	end),

	IsTeamMate = (function(Player1, Player2)
		return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
	end),

	TagHumanoid = (function(humanoid, player)
		local Creator_Tag = Instance.new("ObjectValue")
		Creator_Tag.Name = "creator"
		Creator_Tag.Value = player
		Debris:AddItem(Creator_Tag, 2)
		Creator_Tag.Parent = humanoid
	end),

	UntagHumanoid = (function(humanoid)
		for i, v in pairs(humanoid:GetChildren()) do
			if v:IsA("ObjectValue") and v.Name == "creator" then
				v:Destroy()
			end
		end
	end),
}

return Functions]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX3C3F10C0F67F4BA89EFB3A055EF8A295">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TripScript</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Debris = game:GetService("Debris")

Duration = script:WaitForChild("Duration")

Character = script.Parent
Humanoid = Character:FindFirstChild("Humanoid")

function DestroyScript()
	Debris:AddItem(script, 0.5)
	script:Destroy()
	Humanoid.PlatformStand = false
	Humanoid.AutoRotate = true
end

function Stun()
	Humanoid.PlatformStand = true
	Humanoid.AutoRotate = false
	Humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
end

if not Duration or Duration.Value <= 0 or not Humanoid or Humanoid.Health == 0 then
	DestroyScript()
	return
end

Humanoid:ChangeState(Enum.HumanoidStateType.FallingDown)

Stun()

Humanoid.Changed:connect(function()
	Stun()
end)

wait(Duration.Value)

DestroyScript()]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>