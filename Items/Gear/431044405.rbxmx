<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX090651EE7B4741DE9D5740BB4F88648F">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>-0.523324668</R00>
				<R01>-0.0702147558</R01>
				<R02>-0.849235654</R02>
				<R10>-0.243406817</R10>
				<R11>0.967394352</R11>
				<R12>0.0700105578</R12>
				<R20>0.816629887</R20>
				<R21>0.243348032</R21>
				<R22>-0.523352087</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">ReaperScythe</string>
			<bool name="RequiresHandle">true</bool>
			<Content name="TextureId"><url>rbxassetid://511942532</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX2BAA2EC3559347BA959E295F456EB52C">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-2.16904569</X>
					<Y>5.08487511</Y>
					<Z>25.1129627</Z>
					<R00>0.837265968</R00>
					<R01>-0.542357266</R01>
					<R02>0.0695297718</R02>
					<R10>0.484638005</R10>
					<R11>0.794947386</R11>
					<R12>0.364944935</R12>
					<R20>-0.253203005</R20>
					<R21>-0.271859199</R21>
					<R22>0.928429306</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>2</X>
					<Y>5.5</Y>
					<Z>0.349999994</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBXBD103DDE69594917928FA5FC13FA9114">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxassetid://511942648</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.699999988</X>
						<Y>0.699999988</Y>
						<Z>0.699999988</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxassetid://511942422</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX978A162D561841F48040DBFFC972509C">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Slash</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">1</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBXFDA3A96A594042F4895E316DF9A2ACA2">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

function OnChanged(Property)
	if Property == "Enabled" then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Animation" referent="RBX5A62E1285B6142D893767D2A783FE20F">
			<Properties>
				<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=176223120</url></Content>
				<string name="Name">Equip</string>
			</Properties>
		</Item>
		<Item class="Animation" referent="RBXCE8F8EE9451C4DBF831E063A388E1B02">
			<Properties>
				<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=27763344</url></Content>
				<string name="Name">Slash</string>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXCCDB30201FD548FC89F5A8ADB978F542">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

Handle.Transparency = 0
Tool.Enabled = true

LastAttack = 0
Slashing = false
Debounce = false
ToolEquipped = false

BasePart = Create("Part"){
	Shape = Enum.PartType.Block,
	Material = Enum.Material.Plastic,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	FormFactor = Enum.FormFactor.Custom,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
	Anchored = false,
}

Sounds = {
	Slash = Handle:WaitForChild("Slash")
}

Animations = {
	Slash = {Animation = Tool:WaitForChild("Slash"), Weight = nil, FadeTime = nil, Speed = 1},
	Equip = {Animation = Tool:WaitForChild("Equip"), Weight = nil, FadeTime = nil, Speed = 1},
}

SkeletonRemains = {
	["Head"] = {MeshId = "4770583", TextureId = "36869975", Scale = Vector3.new(3, 3, 3)},
	["Torso"] = {MeshId = "36780113", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Left Arm"] = {MeshId = "36780032", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Right Arm"] = {MeshId = "36780156", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Left Leg"] = {MeshId = "36780079", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Right Leg"] = {MeshId = "36780195", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
}

BaseUrl = "http://www.roblox.com/asset/?id="

NPCScripts = script:WaitForChild("NPCScripts")

Remotes = Tool:WaitForChild("Remotes")
ServerControl = (Remotes:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Remotes

ClientControl = (Remotes:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Remotes

function MakeNPCMinion(Table)
	local HumanoidProperties = (Table.HumanoidProperties or {})
	local Values = (Table.Values or {})
	local Limbs = {
		["Head"] = {Properties = {BrickColor = BrickColor.new("Bright yellow"), Size = Vector3.new(2, 1, 1),}},
		["HumanoidRootPart"] = {Properties = {BrickColor = BrickColor.new("Bright blue"), Transparency = 1, Size = Vector3.new(2, 2, 1),},},
		["Torso"] = {Properties = {BrickColor = BrickColor.new("Bright blue"), Size = Vector3.new(2, 2, 1),},},
		["Left Arm"] = {Properties = {BrickColor = BrickColor.new("Bright yellow"), Size = Vector3.new(1, 2, 1),},},
		["Right Arm"] = {Properties = {BrickColor = BrickColor.new("Bright yellow"), Size = Vector3.new(1, 2, 1),},},
		["Left Leg"] = {Properties = {BrickColor = BrickColor.new("Br. yellowish green"), Size = Vector3.new(1, 2, 1),},},
		["Right Leg"] = {Properties = {BrickColor = BrickColor.new("Br. yellowish green"), Size = Vector3.new(1, 2, 1),},},
	}
	local Joints = {
		["RootJoint"] = {Parent = "HumanoidRootPart", Part0 = "HumanoidRootPart", Part1 = "Torso", Properties = {C0 = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), C1 = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Neck"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Head", Properties = {C0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), C1 = CFrame.new(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Left Shoulder"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Left Arm", Properties = {C0 = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), C1 = CFrame.new(0.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Right Shoulder"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Right Arm", Properties = {C0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), C1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Left Hip"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Left Leg", Properties = {C0 = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), C1 = CFrame.new(-0.5, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Right Hip"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Right Leg", Properties = {C0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), C1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
	}
	local Misc = {
		{Class = "Decal", Parent = "Head", Properties = {Name = "face", Texture = (BaseUrl .. "144080495"), Shiny = 20, Specular = 0, Transparency = 0, Face = Enum.NormalId.Front}},
		{Class = "Decal", Parent = "Torso", Properties = {Name = "roblox", Texture = "", Shiny = 20, Specular = 0, Transparency = 0, Face = Enum.NormalId.Front}},
		{Class = "SpecialMesh", Parent = "Head", Properties = {MeshType = Enum.MeshType.Head, Scale = Vector3.new(1.25, 1.25, 1.25)}},
	}
	local NPC = Create("Model"){
		Name = "NPC",
	}
	local Humanoid = Create("Humanoid"){
		Name = "Humanoid",
	}
	for i, v in pairs(HumanoidProperties) do
		pcall(function()
			Humanoid[i] = v
		end)
	end
	Humanoid.Name = "Humanoid"
	Humanoid.Parent = NPC
	Humanoid.Health = Humanoid.MaxHealth
	for i, v in pairs(Values) do
		local Value = Create(v.Class){
			Name = v.Name,
			Value = v.Value,
			Parent = NPC,
		}
	end
	for i, v in pairs(Limbs) do
		local Limb = BasePart:Clone()
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				Limb[ii] = vv
			end)
		end
		Limb.Name = i
		Limb.Parent = NPC
	end
	for i, v in pairs(Joints) do
		local Joint = Create("Motor"){
		}
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				Joint[ii] = vv
			end)
		end
		Joint.Name = i
		Joint.Part0 = NPC:FindFirstChild(v.Part0)
		Joint.Part1 = NPC:FindFirstChild(v.Part1)
		Joint.Parent = NPC:FindFirstChild(v.Parent)
	end
	for i, v in pairs(Misc) do
		local Decal = Create(v.Class){
		}
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				Decal[ii] = vv
			end)
		end
		Decal.Parent = NPC:FindFirstChild(v.Parent)
	end
	local FakeHat = Create("Hat"){
		Name = "NoHat",
		Parent = NPC,
	}
	for i, v in pairs(NPCScripts:GetChildren()) do
		if v:IsA("Script") then
			local ScriptCopy = v:Clone()
			ScriptCopy.Disabled = false
			ScriptCopy.Parent = NPC
		end
	end
	return NPC
end

function DeathEffect(character, Alive)
	local NoEffect = character:FindFirstChild("NoEffect")
	if NoEffect then
		return
	end
	local function Materialize(Object)
		if Object:IsA("BasePart") then
			Object.BrickColor = BrickColor.new("Institutional white")
			local Remains = SkeletonRemains[Object.Name]
			if Remains then
				for ii, vv in pairs(Object:GetChildren()) do
					if vv:IsA("DataModelMesh") or vv:IsA("Decal") or vv:IsA("Texture") then
						vv:Destroy()
					end
				end
				local NewMesh = Create("SpecialMesh"){
					Name = "Mesh",
					MeshType = Enum.MeshType.FileMesh,
					MeshId = (BaseUrl .. Remains.MeshId),
					TextureId = (BaseUrl .. Remains.TextureId),
					Scale = Remains.Scale,
					VertexColor = Vector3.new(1, 1, 1),
					Offset = Vector3.new(0, 0, 0),
					Parent = Object,
				}
			end
			for ii, vv in pairs(Object:GetChildren()) do
				if vv:IsA("DataModelMesh") then
					vv.VertexColor = Vector3.new(0, 0, 0)
				end
			end
		elseif Object:IsA("CharacterMesh") or Object:IsA("Clothing") then
			Object:Destroy()
		elseif Object:IsA("DataModelMesh") then
			Object.VertexColor = Vector3.new(0, 0, 0)
		end
	end
	local function Effect(Parent)
		for i, v in pairs(Parent:GetChildren()) do
			Materialize(v)
			Effect(v)
		end
	end
	local humanoid = character:FindFirstChild("Humanoid")
	local OwnerCreator = character:FindFirstChild("Creator")
	if humanoid and humanoid.Health <= 0 and (not OwnerCreator or (OwnerCreator and OwnerCreator.Value ~= Player)) then
		local DeadTorso = character:FindFirstChild("Torso")
		local Killer = humanoid:FindFirstChild("creator")
		if Killer and Killer.Value == Player then
			local NoTransform = Killer:FindFirstChild("NoTransform")
			if not NoTransform then
				for i, v in pairs(character:GetChildren()) do
					if not v:IsA("Humanoid") then
						v:Destroy()
					end
				end
				local NPCValues = {
					{Name = "Damage", Class = "NumberValue", Value = 15},
					{Name = "HitDelay", Class = "NumberValue", Value = 0.1},
					{Name = "Creator", Class = "ObjectValue", Value = Player},
				}
				local NPC = MakeNPCMinion({HumanoidProperties = {MaxHealth = 250, WalkSpeed = 24}, Values = NPCValues})
				NPC.Name = "Skeleton"
				NPC.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
				for i, v in pairs(NPC:GetChildren()) do
					if v:IsA("BaseScript") then
						v.Disabled = true
					end
				end
				local ForceField = Create("ForceField"){
				}
				Debris:AddItem(ForceField, 0.75)
				ForceField.Parent = NPC
				DeathEffect(NPC, true)
				local NoEffect = Create("BoolValue"){
					Name = "NoEffect",
					Value = true,
					Parent = NPC
				}
				Debris:AddItem(NPC, 20)
				NPC.Parent = game:GetService("Workspace")
				local torso = NPC:FindFirstChild("Torso")
				if torso then
					torso.CFrame = DeadTorso.CFrame
				end
				for i, v in pairs(NPC:GetChildren()) do
					if v:IsA("BaseScript") then
						v.Disabled = false
					end
				end
			end
		end
	end
	Materialize(character)
	Effect(character)
end

function InvokeClient(Mode, Value)
	local ReturnValue = nil
	pcall(function()
		ReturnValue = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ReturnValue
end

function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function Blow(Hit)
	if not Hit or not Hit.Parent or not ToolEquipped or not CheckIfAlive() or Debounce then
		return
	end
	local character = Hit.Parent
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health == 0 then
		return
	end
	local player = Players:GetPlayerFromCharacter(character)
	if player and (player == Player or IsTeamMate(Player, player)) then
		return
	end
	Debounce = true
	UntagHumanoid(humanoid)
	TagHumanoid(humanoid, Player)
	humanoid:TakeDamage(22)
	if humanoid.Health <= 0 then
		DeathEffect(character, true)
	end
	wait(0.1)
	Debounce = false
end

function Activated()
	if not ToolEquipped or not CheckIfAlive() then
		return
	end
	
	Tool.Enabled = false
	
	Tick = RunService.Stepped:wait()
	if (Tick - LastAttack < 0.2) then
		wait(1)
	else
		if not Slashing then
			Slashing = true
			LastAttack = Tick
			Spawn(function()
				InvokeClient("PlayAnimation", Animations.Slash)
			end)
			Sounds.Slash:Play()
			wait(1)
			Slashing = false
		end
	end
	
	Tool.Enabled = true
	
end

function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end

function Equipped()
	ToolEquipped = true
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("HumanoidRootPart")
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		InvokeClient("PlayAnimation", Animations.Equip)
	end)
end

function Unequipped()	
	ToolEquipped = false
	if CheckIfAlive() then
		Humanoid.WalkSpeed = 16
	end
end

Handle.Touched:connect(Blow)

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
			<Item class="Folder" referent="RBXC75A80D2023745C79A6C171BC2A4D3EA">
				<Properties>
					<string name="Name">NPCScripts</string>
				</Properties>
				<Item class="Script" referent="RBX51B5E1C0F6774A2D9E86A4A553F4D8A5">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AIScript</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Figure = script.Parent
Humanoid = Figure:WaitForChild("Humanoid")
Torso = Figure:WaitForChild("Torso")

Players = game:GetService("Players")

Functions = require(script:WaitForChild("Functions"))

Creator = Figure:WaitForChild("Creator")
HitDelay = Figure:WaitForChild("HitDelay")
Damage = Figure:WaitForChild("Damage")

Rate = (1 / 60)

SpawnOrigin = Torso.Position

TouchDebounce = false

function CheckIfAlive()
	return (((Figure and Figure.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end

function GetCreatorPlayer()
	return (((Creator.Value and Creator.Value.Parent and Creator.Value:IsA("Player")) and Creator.Value) or nil)
end

function GetNearbyObjects(Region)
	local CreatorPlayer = GetCreatorPlayer()
	local IgnoreList = {Figure, ((CreatorPlayer and CreatorPlayer.Character) or nil)}
	for i, v in pairs(Players:GetChildren()) do
		if v:IsA("Player") and v ~= CreatorPlayer and v.Character and v.Character.Parent and (CreatorPlayer and Functions.IsTeamMate(CreatorPlayer, v)) then
			table.insert(IgnoreList, v.Character)
		end
	end
	return Functions.GetParts(Region, 500, IgnoreList)
end

function GetNearbyPlayers(Radius)
	local NearbyObjects = GetNearbyObjects(Radius)
	local Humanoids = {}
	for i, v in pairs(NearbyObjects) do
		local character = v.Parent
		if character then
			local creator = character:FindFirstChild("Creator")
			local humanoid = character:FindFirstChild("Humanoid")
			if (((creator and creator.Value ~= Creator.Value) or not creator) and (humanoid and not Functions.CheckTableForInstance(Humanoids, humanoid))) then
				table.insert(Humanoids, humanoid)
			end
		end
	end
	return Humanoids
end

function SecureJump()
	if not Humanoid or Humanoid.Jump or not Torso then
		return
	end
	local TargetPoint = Torso.Velocity.Unit
	local Blockage, BlockagePos = Functions.CastRay((Torso.CFrame + CFrame.new(Torso.Position, Vector3.new(TargetPoint.X, Torso.Position.Y, TargetPoint.Z)).lookVector * (Torso.Size.Z / 2)).p, Torso.CFrame.lookVector, (Torso.Size.Z * 2.5), {Figure, (((Creator and Creator.Value and Creator.Value:IsA("Player") and Creator.Value.Character) and Creator.Value.Character) or nil)}, false)
	local Jumpable = false
	if Blockage then
		Jumpable = true
		if Blockage:IsA("Terrain") then
			local CellPos = Blockage:WorldToCellPreferSolid((BlockagePos - Vector3.new(0, 2, 0)))
			local CellMaterial, CellShape, CellOrientation = Blockage:GetCell(CellPos.X, CellPos.Y, CellPos.Z)
			if CellMaterial == Enum.CellMaterial.Water then
				Jumpable = false
			end
		elseif Blockage.Parent:FindFirstChild("Humanoid") then
			Jumpable = false
		end
	end
	if Jumpable then
		Humanoid.Jump = true
	end
end

for i, v in pairs(Figure:GetChildren()) do
	if v:IsA("BasePart") then
		local TouchedConnection
		TouchedConnection = v.Touched:connect(function(Hit)
			if not Hit or not Hit.Parent or TouchDebounce then
				return
			end
			local Connected = false
			local ConnectedParts = v:GetConnectedParts()
			if #ConnectedParts <= 1 then
				return
			end
			for i, v in pairs(ConnectedParts) do
				if v == Torso then
					Connected = true
				end
			end
			if not Connected then
				return
			end
			local character = Hit.Parent
			if character:IsA("Hat") then
				character = character.Parent
			end
			local player = Players:GetPlayerFromCharacter(character)
			local CreatorValue = Figure.Creator.Value
			if not CreatorValue then
				return
			end
			local CreatorPlayer = ((CreatorValue:IsA("Player") and CreatorValue) or Players:GetPlayerFromCharacter(CreatorValue))
			if player then
				if player == CreatorPlayer then
					return
				end
				if player and CreatorPlayer and Functions.IsTeamMate(CreatorPlayer, player) then
					return
				end
			end
			local creator = character:FindFirstChild("Creator")
			if creator and creator:IsA("ObjectValue") and creator.Value == CreatorValue then
				return
			end
			local humanoid = character:FindFirstChild("Humanoid")
			if not humanoid or not humanoid:IsA("Humanoid") or humanoid.Health == 0 then
				return
			end
			TouchDebounce = true
			Functions.UntagHumanoid(humanoid)
			Functions.TagHumanoid(humanoid, CreatorPlayer)
			humanoid:TakeDamage(Damage.Value)
			wait(HitDelay.Value)
			TouchDebounce = false
		end)
	end
end

Walk = {Tick = 0, Delay = 0}

while CheckIfAlive() do
	local Now = tick()
	local WalkToPosition = nil
	if (Now - Walk.Tick) > Walk.Delay then
		local MaxDistance = 45
		local NearbyPlayers = GetNearbyPlayers(Region3.new((Torso.Position - Vector3.new(MaxDistance, (Torso.Size.Y * 2), MaxDistance)), (Torso.Position + Vector3.new(MaxDistance, MaxDistance, MaxDistance))))
		if #NearbyPlayers > 0 then
			local ClosestPlayer = {Distance = MaxDistance, Character = nil}
			for i, v in pairs(NearbyPlayers) do
				local humanoid = v
				local character = v.Parent
				if character and character.Parent then
					local humanoid = character:FindFirstChild("Humanoid")
					local torso = character:FindFirstChild("Torso")
					if humanoid and humanoid.Health > 0 and torso then
						local DistanceApart = (Torso.Position - torso.Position).Magnitude
						if DistanceApart < ClosestPlayer.Distance then
							ClosestPlayer.Distance = DistanceApart
							ClosestPlayer.Character = character
						end
					end
				end
			end
			local ClosestCharacter = ClosestPlayer.Character
			if ClosestCharacter and ClosestCharacter.Parent then
				local torso = ClosestCharacter:FindFirstChild("Torso")
				if torso then
					WalkToPosition = torso.Position
				end
			end
		else
			local WalkRadius = 10
			WalkToPosition = (Torso.Position + Vector3.new(math.random(-WalkRadius, WalkRadius), 0, math.random(-WalkRadius, WalkRadius)))
			Walk.Delay = (math.random(500, 3500) * 0.001)
			Walk.Tick = Now
		end
	end
	if WalkToPosition and (SpawnOrigin - WalkToPosition).Magnitude > 75 then
		WalkToPosition = Torso.Position
	end
	if WalkToPosition then
		SecureJump()
		Humanoid:MoveTo(WalkToPosition)
	end
	wait(Rate)
end]]></ProtectedString>
					</Properties>
					<Item class="ModuleScript" referent="RBX79E9AEAA1A434E9393119CBB002D6DDE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Functions</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Debris = game:GetService("Debris")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

Functions = {
	
	CheckTableForString = (function(Table, String)
		for i, v in pairs(Table) do
			if string.lower(v) == string.lower(String) then
				return true
			end
		end
		return false
	end),
	
	CheckIntangible = (function(Hit)
		local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Laser", "Ray", "Bullet", "ParticlePart"}
		if Hit and Hit.Parent then
			if (Hit.Transparency >= 1 and not Hit.CanCollide) or Functions.CheckTableForString(ProjectileNames, Hit.Name) then
				return true
			end
			local ObjectParent = Hit.Parent
			local Character = ObjectParent.Parent
			local Humanoid = Character:FindFirstChild("Humanoid")
			if Humanoid and Humanoid.Health > 0 and ObjectParent:IsA("Hat") then
				return true
			end
		end
		return false
	end),
	
	CastRay = (function(StartPos, Vec, Length, Ignore, DelayIfHit)
		local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
		if RayHit and Functions.CheckIntangible(RayHit) then
			if DelayIfHit then
				wait()
			end
			RayHit, RayPos, RayNormal = Functions.CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
		end
		return RayHit, RayPos, RayNormal
	end),

	TagHumanoid = (function(humanoid, player)
		local Creator_Tag = Create("ObjectValue"){
			Name = "creator",
			Value = player,
		}
		local NoTransform = Create("BoolValue"){
			Name = "NoTransform",
			Value = true,
			Parent = Creator_Tag,
		}
		Debris:AddItem(Creator_Tag, 2)
		Creator_Tag.Parent = humanoid
	end),
	
	UntagHumanoid = (function(humanoid)
		for i, v in pairs(humanoid:GetChildren()) do
			if v:IsA("ObjectValue") and v.Name == "creator" then
				v:Destroy()
			end
		end
	end),
	
	IsTeamMate = (function(Player1, Player2)
		return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
	end),
	
	Clamp = (function(Number, Min, Max)
		return math.max(math.min(Max, Number), Min)
	end),
	
	GetPercentage = (function(Start, End, Number)
		return (((Number - Start) / (End - Start)) * 100)
	end),
	
	Round = (function(Number, RoundDecimal)
		local WholeNumber, Decimal = math.modf(Number)
		return ((Decimal >= RoundDecimal and math.ceil(Number)) or (Decimal < RoundDecimal and math.floor(Number)))
	end),
	
	CheckTableForInstance = (function(Table, Instance)
		for i, v in pairs(Table) do
			if v == Instance then
				return true
			end
		end
		return false
	end),
	
	GetAllConnectedParts = (function(Object)
		local Parts = {}
		local function GetConnectedParts(Object)
			for i, v in pairs(Object:GetConnectedParts()) do
				local Ignore = false
				for ii, vv in pairs(Parts) do
					if v == vv then
						Ignore = true
					end
				end
				if not Ignore then
					table.insert(Parts, v)
					GetConnectedParts(v)
				end
			end
		end
		GetConnectedParts(Object)
		return Parts
	end),
	
	GetTotalParts = (function(MaxParts, PossibleParts, Parts)
		if MaxParts < PossibleParts then
			return MaxParts
		elseif Parts >= MaxParts then
			return 0
		elseif MaxParts >= PossibleParts then
			local PartCount = (MaxParts - PossibleParts)
			if Parts <= MaxParts then
				PartCount = (MaxParts - Parts)
				if PartCount > PossibleParts then
					return PossibleParts
				else
					return PartCount
				end
			elseif PartCount >= PossibleParts then
				return PossibleParts
			else
				return PartCount
			end
		end
	end),
	
	GetParts = (function(Region, MaxParts, Ignore)
		local Parts = {}
		local RerunFailed = false
		while #Parts < MaxParts and not RerunFailed do
			local Region = Region
			local PossibleParts = Functions.GetTotalParts(MaxParts, 100, #Parts)
			local PartsNearby = game:GetService("Workspace"):FindPartsInRegion3WithIgnoreList(Region, Ignore, PossibleParts)
			if #PartsNearby == 0 then
				RerunFailed = true
			else
				for i, v in pairs(PartsNearby) do
					table.insert(Parts, v)
					table.insert(Ignore, v)
				end
			end
		end
		return Parts
	end),
	
}

return Functions]]></ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="Script" referent="RBXCB61164B7A87423582AD8C5D32EB39AE">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RegenerateHealth</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Figure = script.Parent
Humanoid = Figure:WaitForChild("Humanoid")

Regenerating = false

function RegenerateHealth()
	if Regenerating then
		return
	end
	Regenerating = true
	while Humanoid.Health < Humanoid.MaxHealth do
		local Second = wait(1)
		local Health = Humanoid.Health
		if Health > 0 and Health < Humanoid.MaxHealth then
			local NewHealthDelta = (0.01 * Second * Humanoid.MaxHealth)
			Health = (Health + NewHealthDelta)
			Humanoid.Health = math.min(Health, Humanoid.MaxHealth)
		end
	end
	if Humanoid.Health > Humanoid.MaxHealth then
		Humanoid.Health = Humanoid.MaxHealth
	end
	Regenerating = false
end

Humanoid.HealthChanged:connect(RegenerateHealth)]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX4817E82524B84885892ABB576BDC96D7">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Figure = script.Parent

RunService = game:GetService("RunService")
Debris = game:GetService("Debris")

Creator = Figure:FindFirstChild("Creator")

Humanoid = Figure:WaitForChild("Humanoid")
Head = Figure:WaitForChild("Head")
Torso = Figure:WaitForChild("Torso")

Neck = Torso:WaitForChild("Neck")
LeftShoulder = Torso:WaitForChild("Left Shoulder")
RightShoulder = Torso:WaitForChild("Right Shoulder")
LeftHip = Torso:WaitForChild("Left Hip")
RightHip = Torso:WaitForChild("Right Hip")

for i, v in pairs({Neck, LeftShoulder, RightShoulder, LeftHip, RightHip}) do
	if v and v.Parent then
		v.DesiredAngle = 0
		v.CurrentAngle = 0
	end
end

Pose = "None"
LastPose = Pose
PoseTime = tick()

ToolAnimTime = 0

function SetPose(pose)
	LastPose = Pose
	Pose = pose
	PoseTime = tick()
end

function OnRunning(Speed)
	if Speed > 0 then
		SetPose("Running")
	else
		SetPose("Standing")
	end
end

function OnDied()
	SetPose("Dead")
	Debris:AddItem(Figure, 3)
end

function OnJumping()
	SetPose("Jumping")
end

function OnClimbing()
	SetPose("Climbing")
end

function OnGettingUp()
	SetPose("GettingUp")
end

function OnFreeFall()
	SetPose("FreeFall")
end

function OnFallingDown()
	SetPose("FallingDown")
end

function OnSeated()
	SetPose("Seated")
end

function OnPlatformStanding()
	SetPose("PlatformStanding")
end

function OnSwimming(Speed)
	return OnRunning(Speed)
end

function MoveJump()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder.DesiredAngle = math.pi
	LeftShoulder.DesiredAngle = -math.pi
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function MoveFreeFall()
	RightShoulder.MaxVelocity = 0.25
	LeftShoulder.MaxVelocity = 0.25
	RightShoulder.DesiredAngle = math.pi
	LeftShoulder.DesiredAngle = -math.pi
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0	
end

function MoveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder.DesiredAngle = (math.pi / 2)
	LeftShoulder.DesiredAngle = -(math.pi / 2)
	RightHip.DesiredAngle = 1
	LeftHip.DesiredAngle = -1
end

function GetTool()	
	for i, v in pairs(Figure:GetChildren()) do
		if v:IsA("Tool") then
			return v
		end
	end
end

function GetToolAnim(Tool)
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("StringValue") and v.Name == "ToolAnim" then
			return v
		end
	end
	return nil
end

function AnimateTool()
	
	if (ToolAnim == "None") then
		return
	end

	if (ToolAnim == "Slash") then
		RightShoulder.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = 0
		return
	end

	if (ToolAnim == "Lunge") then
		RightShoulder.MaxVelocity = 0.5
		LeftShoulder.MaxVelocity = 0.5
		RightHip.MaxVelocity = 0.5
		LeftHip.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = (math.pi / 2)
		LeftShoulder.DesiredAngle = 0 
		RightHip.DesiredAngle = (math.pi / 2)
		LeftHip.DesiredAngle = 1
		return
	end
	
end

function Move(Time)
	local LimbAmplitude
	local LimbFrequency
	local NeckAmplitude
	local NeckFrequency
	local NeckDesiredAngle
  
	if (Pose == "Jumping") then
		MoveJump()
		return
	elseif (Pose == "FreeFall") then
		MoveFreeFall()
		return
	elseif (Pose == "Seated") then
		MoveSit()
		return
	end

	local ClimbFudge = 0
	
	if (Pose == "Running") then
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		LimbAmplitude = 1
		LimbFrequency = 9
		NeckAmplitude = 0
		NeckFrequency = 0
		NeckDesiredAngle = 0
		--[[if Creator and Creator.Value and Creator.Value:IsA("Player") and Creator.Value.Character then
			local CreatorCharacter = Creator.Value.Character
			local CreatorHead = CreatorCharacter:FindFirstChild("Head")
			if CreatorHead then
				local TargetPosition = CreatorHead.Position
				local Direction = Torso.CFrame.lookVector
				local HeadPosition = Head.Position
				NeckDesiredAngle = ((((HeadPosition - TargetPosition).Unit):Cross(Direction)).Y / 4)
			end
		end]]
	elseif (Pose == "Climbing") then
		RightShoulder.MaxVelocity = 0.5
		LeftShoulder.MaxVelocity = 0.5
		LimbAmplitude = 1
		LimbFrequency = 9
		NeckAmplitude = 0
		NeckFrequency = 0
		NeckDesiredAngle = 0
		ClimbFudge = math.pi
	else
		LimbAmplitude = 0.1
		LimbFrequency = 1
		NeckAmplitude = 0.25
		NeckFrequency = 1.25
	end

	NeckDesiredAngle = ((not NeckDesiredAngle and (NeckAmplitude * math.sin(Time * NeckFrequency))) or NeckDesiredAngle)
	LimbDesiredAngle = (LimbAmplitude * math.sin(Time * LimbFrequency))
	
	--Neck.DesiredAngle = NeckDesiredAngle
	RightShoulder.DesiredAngle = (LimbDesiredAngle + ClimbFudge)
	LeftShoulder.DesiredAngle = (LimbDesiredAngle - ClimbFudge)
	RightHip.DesiredAngle = -LimbDesiredAngle
	LeftHip.DesiredAngle = -LimbDesiredAngle
	
	local Tool = GetTool()

	if Tool then
	
		AnimStringValueObject = GetToolAnim(Tool)

		if AnimStringValueObject then
			ToolAnim = AnimStringValueObject.Value
			if AnimStringValueObject and AnimStringValueObject.Parent then
				AnimStringValueObject:Destroy()
			end
			ToolAnimTime = (Time + 0.3)
		end

		if Time > ToolAnimTime then
			ToolAnimTime = 0
			ToolAnim = "None"
		end

		AnimateTool()
		
	else
		ToolAnim = "None"
		ToolAnimTime = 0
	end
	
end

Humanoid.Died:connect(OnDied)
Humanoid.Running:connect(OnRunning)
Humanoid.Jumping:connect(OnJumping)
Humanoid.Climbing:connect(OnClimbing)
Humanoid.GettingUp:connect(OnGettingUp)
Humanoid.FreeFalling:connect(OnFreeFall)
Humanoid.FallingDown:connect(OnFallingDown)
Humanoid.Seated:connect(OnSeated)
Humanoid.PlatformStanding:connect(OnPlatformStanding)
Humanoid.Swimming:connect(OnSwimming)

Humanoid:ChangeState(Enum.HumanoidStateType.None)

RunService.Stepped:connect(function()
	local _, Time = wait(0.1)
	Move(Time)
end)]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX93B521C50584415688091064BD097E5C">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
RunService = game:GetService("RunService")

Animations = {}

Remotes = Tool:WaitForChild("Remotes")
ServerControl = Remotes:WaitForChild("ServerControl")
ClientControl = Remotes:WaitForChild("ClientControl")

Rate = (1 / 60)

ToolEquipped = false

function SetAnimation(mode, value)
	if mode == "PlayAnimation" and value and ToolEquipped and Humanoid then
		for i, v in pairs(Animations) do
			if v.Animation == value.Animation then
				v.AnimationTrack:Stop()
				table.remove(Animations, i)
			end
		end
		local AnimationTrack = Humanoid:LoadAnimation(value.Animation)
		table.insert(Animations, {Animation = value.Animation, AnimationTrack = AnimationTrack})
		AnimationTrack:Play(value.FadeTime, value.Weight, value.Speed)
	elseif mode == "StopAnimation" and value then
		for i, v in pairs(Animations) do
			if v.Animation == value.Animation then
				v.AnimationTrack:Stop(value.FadeTime)
				table.remove(Animations, i)
			end
		end
	end
end

function KeyPressed(Key, Down)
	InvokeServer("KeyPressed", {Key = Key, Down = Down})
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Player and Player.Parent) and true) or false)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	ToolEquipped = true
	if not CheckIfAlive() then
		return
	end
	PlayerMouse = Mouse
	PlayerMouse.KeyDown:connect(function(Key)
		KeyPressed(Key, true)
	end)
	PlayerMouse.KeyUp:connect(function(Key)
		KeyPressed(Key, false)
	end)
end

function Unequipped()
	for i, v in pairs(Animations) do
		if v and v.AnimationTrack then
			v.AnimationTrack:Stop()
		end
	end
	Animations = {}
	ToolEquipped = false
end

function InvokeServer(mode, value)
	local ServerReturn
	pcall(function()
		ServerReturn = ServerControl:InvokeServer(mode, value)
	end)
	return ServerReturn
end

function OnClientInvoke(mode, value)
	if mode == "PlayAnimation" and value and ToolEquipped and Humanoid then
		SetAnimation("PlayAnimation", value)
	elseif mode == "StopAnimation" and value then
		SetAnimation("StopAnimation", value)
	elseif mode == "PlaySound" and value then
		value:Play()
	elseif mode == "StopSound" and value then
		value:Stop()
	elseif mode == "MouseData" then
		return ((PlayerMouse and {Position = PlayerMouse.Hit.p, Target = PlayerMouse.Target}) or nil)
	end
end

ClientControl.OnClientInvoke = OnClientInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX2353A278F2984B83BED4DD374459C747">
			<Properties>
				<string name="Name">Remotes</string>
			</Properties>
			<Item class="RemoteFunction" referent="RBXBE0C517ABA44468391D61F93634935EC">
				<Properties>
					<string name="Name">ServerControl</string>
				</Properties>
			</Item>
			<Item class="RemoteFunction" referent="RBX0D779AF23E724E12B7B3EEC0E07B1ABE">
				<Properties>
					<string name="Name">ClientControl</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Camera" referent="RBX734B72E28282466489F25ED83C579793">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>-1.73024595</X>
					<Y>5.56943798</Y>
					<Z>16.4627762</Z>
					<R00>-0.999122798</R00>
					<R01>-0.000657750061</R01>
					<R02>0.0418709926</R02>
					<R10>-0</R10>
					<R11>0.999876678</R11>
					<R12>0.0157070309</R12>
					<R20>-0.0418761559</R20>
					<R21>0.0156932529</R21>
					<R22>-0.998999596</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">40</float>
				<CoordinateFrame name="Focus">
					<X>-1.81398785</X>
					<Y>5.53802395</Y>
					<Z>18.4607735</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>