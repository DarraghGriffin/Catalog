<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX2D8BCDD48C5144598D877D84FF7EF99C">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>1.125</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">TeslaElectricGun</string>
			<bool name="RequiresHandle">true</bool>
			<Content name="TextureId"><url>rbxassetid://502811432</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX2CA998F8B0B1418688337356C9B0C19E">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>15.6820335</X>
					<Y>0.593773007</Y>
					<Z>26.274559</Z>
					<R00>-0.998147786</R00>
					<R01>-0.0254134275</R01>
					<R02>-0.0552747361</R02>
					<R10>0</R10>
					<R11>0.908571303</R11>
					<R12>-0.417729884</R12>
					<R20>0.0608369857</R20>
					<R21>-0.416956127</R21>
					<R22>-0.906888366</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.375</X>
					<Y>1.125</Y>
					<Z>2.75</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX6B09A092CA7C43EF9C7D5225D11E91FA">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=502811730</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.400000006</X>
						<Y>0.400000006</Y>
						<Z>0.400000006</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxassetid://502811337</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX7CF66558FC4242E3AA2E492C38B44B8A">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Fire</string>
					<float name="Pitch">2.06399989</float>
					<bool name="PlayOnRemove">false</bool>
					<bool name="Playing">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=156190087</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">1</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
					<float name="xmlRead_MinDistance_3">10</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX75FBE31581D649B380452727BF63B9FC">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
RunService = game:GetService("RunService")

ServerControl = Tool:WaitForChild("ServerControl")
ClientControl = Tool:WaitForChild("ClientControl")

ToolEquipped = false

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Player and Player.Parent) and true) or false)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	if not CheckIfAlive() then
		return
	end
	PlayerMouse = Player:GetMouse()
	ToolEquipped = true
end

function Unequipped()
	ToolEquipped = false
end

function InvokeServer(mode, value)
	local ServerReturn
	pcall(function()
		ServerReturn = ServerControl:InvokeServer(mode, value)
	end)
	return ServerReturn
end

function OnClientInvoke(mode, value)
	if not ToolEquipped or not CheckIfAlive() or not mode then
		return
	end
	if mode == "MouseData" then
		return {Position = PlayerMouse.Hit.p, Target = PlayerMouse.Target}
	end
end

ClientControl.OnClientInvoke = OnClientInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBXF6035A0AF34A45249C03494E95B993F0">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

function OnChanged(Property)
	if Property == "Enabled" then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX438FD4AB94A64C6B9F31DF743B50DD2E">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Mesh = Handle:WaitForChild("Mesh")

Players = game:GetService("Players")
Debris = game:GetService("Debris")

BaseUrl = "http://www.roblox.com/asset/?id="

LightningFunctions = require(script:WaitForChild("LightningFunctions"))
StunScript = script:WaitForChild("StunScript")

BasePart = Instance.new("Part")
BasePart.Material = Enum.Material.Plastic
BasePart.Shape = Enum.PartType.Block
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.Locked = true
BasePart.CanCollide = true
BasePart.Anchored = false

BaseSlime = BasePart:Clone()
BaseSlime.Name = "Slime"
BaseSlime.BrickColor = BrickColor.new("Lime green")
BaseSlime.Size = Vector3.new(0.5, 1.25, 0.5)
BaseSlime.CanCollide = false
SlimeMesh = Instance.new("CylinderMesh")
SlimeMesh.Scale = (Vector3.new(1, 1, 1) * BaseSlime.Size)
SlimeMesh.VertexColor = Vector3.new(1, 1, 1)
SlimeMesh.Offset = Vector3.new(0, 0, 0)
SlimeMesh.Parent = BaseSlime

Animations = {}

Sounds = {
	Fire = Handle:WaitForChild("Fire"),
}

ReloadTime  = 1.25

ToolEquipped = false

ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool

ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool

Tool.Enabled = true

function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function CreateDisplay(Create)
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			v:Destroy()
		end
	end
	Mesh.MeshId = (BaseUrl .. ((Create and "502811607") or "502811730"))
	if not Create then
		return
	end
	local BigCoil = BasePart:Clone()
	BigCoil.Name = "BigCoil"
	local CoilMesh = Instance.new("SpecialMesh")
	CoilMesh.Name = "Mesh"
	CoilMesh.MeshType = Enum.MeshType.FileMesh
	CoilMesh.MeshId = (BaseUrl .. "502811563")
	CoilMesh.TextureId = (BaseUrl .. "502811337")
	CoilMesh.Scale = Mesh.Scale
	CoilMesh.VertexColor = Vector3.new(1, 1, 1)
	CoilMesh.Offset = Vector3.new(0, 0, 0)
	CoilMesh.Parent = BigCoil
	BigCoilMotor = Instance.new("Motor6D")
	BigCoilMotor.Name = "Motor"
	BigCoilMotor.Part0 = Handle
	BigCoilMotor.Part1 = BigCoil
	BigCoilMotor.C0 = CFrame.new(0, 0.405, -0.585)
	BigCoilMotor.C1 = CFrame.new(0, 0, 0)
	--BigCoilMotor.MaxVelocity = 0.1
	BigCoilMotor.CurrentAngle = 0
	BigCoilMotor.DesiredAngle = 999999999
	BigCoilMotor.Parent = BigCoil
	local SmallCoil = BigCoil:Clone()
	SmallCoil.Name = "SmallCoil"
	SmallCoil.Mesh.MeshId = (BaseUrl .. "502811659")
	SmallCoilMotor = SmallCoil.Motor
	SmallCoilMotor.C0 = CFrame.new(0, 0.425, 0.495)
	BigCoil.Parent = Tool
	SmallCoil.Parent = Tool
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Head and Head.Parent) and true) or false)
end

function Activated()
	local MouseData = InvokeClient("MouseData")
	if not MouseData or not MouseData.Position then
		return
	end
	if not Tool.Enabled or not ToolEquipped or not CheckIfAlive() then
		return
	end
	Tool.Enabled = false
	Sounds.Fire.Pitch = (math.random(1250, 2500) * 0.001)
	Sounds.Fire:Play()
	local StartPosition = (Handle.CFrame * CFrame.new(0, ((Handle.Size.Y / 3)), -((Handle.Size.Z / 2) - 0))).p
	local TargetPosition = MouseData.Position
	LightningFunctions.RemoveLightning()
	local HitData = LightningFunctions.Zap({StartPosition = StartPosition, TargetPosition = TargetPosition, Character = Character, Color = "Cyan", Individual = false, Duration = 2, TimeToFade = 0.375, MaxRange = 30, SegmentLength = 1.25, Thickness = 0.75, Ignore = {Character}})
	Spawn(function()
		if not HitData or not HitData.RayHit then
			return
		end
		local Hit = HitData.RayHit
		if not Hit or not Hit.Parent then
			return
		end
		local character = Hit.Parent
		if character:IsA("Hat") or character:IsA("Tool") then
			character = character.Parent
		end
		local player = Players:GetPlayerFromCharacter(character)
		if player == Player or IsTeamMate(Player, player) then
			return
		end
		if character == Character then
			return
		end
		local humanoid = character:FindFirstChild("Humanoid")
		if not humanoid or humanoid.Health == 0 then
			return
		end
		local StunScriptCopy = character:FindFirstChild(StunScript.Name)
		if not StunScriptCopy then
			StunScriptCopy = StunScript:Clone()
			local Duration = Instance.new("NumberValue")
			Duration.Name = "Duration"
			Duration.Value = 2
			Duration.Parent = StunScriptCopy
			StunScriptCopy.Disabled = false
			StunScriptCopy.Parent = character
		end
		UntagHumanoid(humanoid)
		TagHumanoid(humanoid, Player)
		humanoid:TakeDamage(15)
	end)
	Spawn(function()
		for i, v in pairs({BigCoilMotor, SmallCoilMotor}) do
			v.MaxVelocity = 1
		end
		local DecreaseRate = 100
		local WaitRate = 0.03
		local FireSound = Sounds.Fire
		local MotorDecreaseAmount = (BigCoilMotor.MaxVelocity / DecreaseRate)
		local FireVolume = (FireSound.Volume / DecreaseRate)
		local FirePitch = (FireSound.Pitch / DecreaseRate)
		for i = 1, DecreaseRate do
			local DecreaseAmount = (DecreaseRate - i)
			for ii, vv in pairs({SmallCoilMotor, BigCoilMotor}) do
				vv.MaxVelocity = (MotorDecreaseAmount * DecreaseAmount)
			end
			wait(WaitRate)
		end
	end)
	wait(ReloadTime)
	Tool.Enabled = true
end

function Equipped()
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Head = Character:FindFirstChild("Head")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		CreateDisplay(true)
	end)
	ToolEquipped = true
end

function Unequipped()
	Spawn(function()
		CreateDisplay(false)
	end)
	ToolEquipped = false
end

function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end

Delay(0, (function()
	if ToolEquipped then
		return
	end
	CreateDisplay(false)
end))

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
			<Item class="ModuleScript" referent="RBXC18F2851764247E89850727F451EEE01">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LightningFunctions</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

LightningModelRemoval = script:WaitForChild("LightningModelRemoval")

BasePart = Create("Part"){
	Material = Enum.Material.Plastic,
	Shape = Enum.PartType.Block,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	FormFactor = Enum.FormFactor.Custom,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
}

BaseLightning = BasePart:Clone()
BaseLightning.Name = "Effect"
BaseLightning.Transparency = 0.1
BaseLightning.Material = Enum.Material.Neon
BaseLightning.Anchored = true
BaseLightning.CanCollide = false

Rate = 0.05

LightningBolts = {}
LastBolt = nil

function GetLightningModel()
	local LightningModelName = "LightningModel"
	local LightningModel = game:GetService("Workspace"):FindFirstChild(LightningModelName)
	if not LightningModel then
		LightningModel = Create("Model"){
			Name = LightningModelName,
		}
		local LightningModelRemovalClone = LightningModelRemoval:Clone()
		LightningModelRemovalClone.Disabled = false
		LightningModelRemovalClone.Parent = LightningModel
		LightningModel.Parent = game:GetService("Workspace")
	end
	return LightningModel
end

function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end

function CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Lightning", "Bullet"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end

function CastRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end

function Clamp(Number, Min, Max)
	return math.max(math.min(Max, Number), Min)
end

function GetPercentage(Start, End, Number)
	return (((Number - Start) / (End - Start)) * 100)
end

function Round(Number, RoundDecimal)
	local WholeNumber, Decimal = math.modf(Number)
	return ((Decimal >= RoundDecimal and math.ceil(Number)) or (Decimal < RoundDecimal and math.floor(Number)))
end

function Zap(Table)
	local StartPos, TargetPos, Character, Color = Table.StartPosition, Table.TargetPosition, Table.Character, Table.Color
	local Duration = (Table.Duration or 2)
	local FadeRate = (Table.FadeRate or 0.05)
	local Individualize = (Table.Individualize or false)
	local MaxRange = (Table.MaxRange or 40)
	local SegmentLength = (Table.SegmentLength or 5)
	local TimeToFade = (Table.TimeToFade or 0.5)
	local Ignore = (Table.Ignore or {})
	local Thickness = (Table.Thickness or 0.4)
	if not StartPos or not TargetPos or not Character then
		return
	end
	local LightningModel = GetLightningModel()
	for i, v in pairs({Character, LightningModel}) do
		table.insert(Ignore, v)
	end
	local LastPos = StartPos
	local Direction = CFrame.new(StartPos, TargetPos).lookVector
	local RayHit, RayPos, RayNormal = CastRay(StartPos, Direction, MaxRange, Ignore, false)
	local RayLength = (StartPos - RayPos).Magnitude
	local Struck = false
	local TotalSegments = math.ceil(RayLength / SegmentLength)
	Direction = CFrame.new(StartPos, RayPos).lookVector
	local LightningBolt = Create("Model"){
		Name = "LightningBolt",
	}
	if not Individualize then
		table.insert(LightningBolts, LightningBolt)
	end
	LastBolt = LightningBolt
	Debris:AddItem(LightningBolt, Duration)
	LightningBolt.Parent = LightningModel
	for i = 1, TotalSegments do
		if not Struck then
			local Entropy = Vector3.new(((math.random() * 0.125) - 0), ((math.random() * 0.25) - 0), 0) --Vector3.new(((math.random() * 2) - 1), ((math.random() * 2) - 1), ((math.random() * 2) - 1))
			local NewPos = (StartPos + (Direction * (RayLength * (i / TotalSegments))) + Entropy)
			local SegmentVec = (NewPos - LastPos)
			local RayHit, RayPos, RayNormal = CastRay(LastPos, SegmentVec.Unit, SegmentVec.Magnitude, {Character, LightningModel}, false) 
			local RayVec = (LastPos - RayPos)
			local LightningPart = BaseLightning:Clone()
			LightningPart.BrickColor = BrickColor.new(Color)
			LightningPart.Size = Vector3.new(0.2, 0.2, RayVec.Magnitude)
			LightningPart.CFrame = (CFrame.new(LastPos, RayPos) * CFrame.new(0, 0, -(RayVec.Magnitude / 2)))
			Debris:AddItem(LightningPart, (Duration - 0.5))
			local Light = Create("PointLight"){
				Name = "Light",
				Color = BrickColor.new(Color).Color,
				Brightness = 50,
				Range = 2,
				Shadows = false,
				Enabled = true,
				Parent = LightningPart,
			}
			--Make circular
			local CylinderMesh = Create("CylinderMesh"){
				Name = "Mesh",
				Scale = Vector3.new(Thickness, 1, Thickness),
				Parent = LightningPart,
			}
			local OrigCF = LightningPart.CFrame
			LightningPart.Size = Vector3.new(LightningPart.Size.X, LightningPart.Size.Z, LightningPart.Size.Y)
			LightningPart.CFrame = (OrigCF * CFrame.Angles((math.pi / 2), 0, 0))
			LightningPart.Parent = LightningBolt
			LastPos = NewPos
			Spawn(function()
				local FadeRate = 0.05
				local OrigTransparency = LightningPart.Transparency
				for i = 1, (TimeToFade / FadeRate) do
					wait(FadeRate)
					LightningPart.Transparency = (OrigTransparency + (i / (TimeToFade / FadeRate)))
					for ii, vv in pairs(LightningPart:GetChildren()) do
						if vv:IsA("Light") then
							vv.Brightness = (50 - (50 * (GetPercentage(0, 1, LightningPart.Transparency) * 0.01)))
							if vv.Brightness <= 0 then
								vv.Enabled = false
							end
						end
					end
				end
			end)
		end
	end
	return {RayHit = RayHit, RayPos = RayPos, RayNormal = RayNormal, LightningModel = LightningModel}
end

function RemoveLightning()
	for i, v in pairs(LightningBolts) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	LightningBolts = {}
end

Functions = {
	Zap = Zap,
	RemoveLightning = RemoveLightning,
}

return Functions]]></ProtectedString>
				</Properties>
				<Item class="Script" referent="RBX75EF6B4118CB4A97A5D8401F60C2F242">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LightningModelRemoval</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Model = script.Parent

Debris = game:GetService("Debris")

FadeRate = 0.025
Rate = (1 / 15)

Removing = false

function RemoveModel()
	if Removing then
		return
	end
	local Parts = {}
	for i, v in pairs(Model:GetChildren()) do
		if v:IsA("Model") then
			table.insert(Parts, v)
		end
	end
	if #Parts == 0 then
		Removing = true
		Model.Name = ""
		Debris:AddItem(Model, 0.5)
	end
end

Model.ChildRemoved:connect(function(Child)
	RemoveModel()
end)

wait(1.5)

RemoveModel()]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBX83C26C59F7A44B5BB83B23CBF5BAE531">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StunScript</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Character = script.Parent
Humanoid = Character:FindFirstChild("Humanoid")
Head = Character:FindFirstChild("Head")

Players = game:GetService("Players")
Debris = game:GetService("Debris")

Player = Players:GetPlayerFromCharacter(Character)

Duration = script:FindFirstChild("Duration")

BaseColor = BrickColor.new("Electric blue")
DarkProperties = {
	All = {
		--BrickColor = BaseColor,
		Material = Enum.Material.Ice,
		TextureId = "",
		Texture = "",
		VertexColor = Vector3.new(BaseColor.Color.r, BaseColor.Color.g, BaseColor.Color.b),
		--BaseTextureId = 0,
		--OverlayTextureId = 0,
		SparkleColor = BaseColor.Color,
		Color = BaseColor.Color,
		SecondaryColor = BaseColor.Color,
	},
	Class = {
		BasePart = {
			Reflectance = 1,
			Anchored = true,
		},
		ParticleEmitter = {
			Color = ColorSequence.new(BaseColor.Color, BaseColor.Color),
		},
		Sparkles = {
			Color = BaseColor.Color,
			SparkleColor = BaseColor.Color,
		},
		Decal = {
			Texture = "",
		},
	}
}

RemovedObjects = {}

function GetAllInstances(Parent)
	local Instances = {}
	local function GetInstances(Parent)
		for i, v in pairs(Parent:GetChildren()) do
			table.insert(Instances, v)
			GetInstances(v)
		end
	end
	GetInstances(Parent)
	return Instances
end

function Freeze()
	local FrozenInstances = GetAllInstances(Character)
	OriginalInstances = {}
	for i, v in pairs(FrozenInstances) do
		local NewInstance = {Object = v, Properties = {}}
		local PropertiesAltered = {}
		if v:IsA("BasePart") and v.Name == "HumanoidRootPart" then
		elseif v:IsA("CharacterMesh") then
			local Mesh = Instance.new("SpecialMesh")
			Mesh.MeshType = Enum.MeshType.FileMesh
			Mesh.MeshId = ("http://www.roblox.com/asset/?id=" .. v.MeshId)
			for ii, vv in pairs(Character:GetChildren()) do
				if vv:IsA("BasePart") and v.BodyPart.Name == string.gsub(vv.Name, " ", "") then
					Mesh.Parent = vv
					table.insert(RemovedObjects, {Object = v, NewObject = Mesh, Parent = v.Parent})
					v.Parent = nil
				end
			end
		elseif v:IsA("Decal") and v.Name == "face" then
		else
			for ii, vv in pairs(DarkProperties.All) do
				pcall(function()
					NewInstance.Properties[ii] = v[ii]
					PropertiesAltered[ii] = true
					v[ii] = vv
				end)
			end
			for ii, vv in pairs(DarkProperties.Class) do
				if v:IsA(ii) then
					for iii, vvv in pairs(vv) do
						--if not PropertiesAltered[iii] then
							pcall(function()
								NewInstance.Properties[iii] = v[iii]
								v[iii] = vvv
							end)
						--end
					end
				end
			end
		end
		table.insert(OriginalInstances, NewInstance)
	end
end

function Unfreeze()
	for i, v in pairs(RemovedObjects) do
		if v then
			if v.NewObject and v.NewObject.Parent then
				v.NewObject:Destroy()
			end
			v.Object.Parent = v.Parent
		end
	end
	for i, v in pairs(OriginalInstances) do
		if v.Object then
			for ii, vv in pairs(v.Properties) do
				pcall(function()
					v.Object[ii] = vv
				end)
			end
		end
	end
end

Freeze()
if Duration and Duration.Value >= 0 then
	wait(Duration.Value)
	Unfreeze()
end

script:Destroy()]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Camera" referent="RBX289DBB1923E942D2B37DC7E838723CB3">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>12.9813499</X>
					<Y>1.26754785</Y>
					<Z>27.5623722</Z>
					<R00>0.372966528</R00>
					<R01>0.17322138</R01>
					<R02>-0.911531806</R02>
					<R10>-7.45058149e-009</R10>
					<R11>0.982418418</R11>
					<R12>0.186692193</R12>
					<R20>0.927844822</R20>
					<R21>-0.06962993</R21>
					<R22>0.366409183</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">40</float>
				<CoordinateFrame name="Focus">
					<X>15.6247997</X>
					<Y>0.726138949</Y>
					<Z>26.4997826</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>