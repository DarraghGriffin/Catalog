<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX59CED7360B6A4087BC19324E276D8908">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0.300000012</X>
				<Y>-0.5</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">RCTank</string>
			<bool name="RequiresHandle">true</bool>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=81616223</url></Content>
			<string name="ToolTip">RC Tank</string>
		</Properties>
		<Item class="Script" referent="RBX6677905A977441388CB693E4DFE42F6F">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script</string>
				<string name="ScriptGuid">{50353178-C644-4097-81B8-04638D0B4FCA}</string>
				<ProtectedString name="Source"><![CDATA[--Rescripted by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Mesh = Handle:WaitForChild("Mesh")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

RbxUtility = LoadLibrary("RbxUtility")

Create = RbxUtility.Create

Remover = script:WaitForChild("Remover")

Tank = nil

Directions = {
	Forward = {
		Keys = {
			Key = "w",
			ByteKey = 17,
		},
		Direction = Vector3.new(0, 1, 0),
		State = false,
		LastDown = 0
	},
	Backward = {
		Keys = {
			Key = "s",
			ByteKey = 18,
		},
		Direction = Vector3.new(0, -1, 0),
		State = false,
		LastDown = 0
	},
	Left = {
		Keys = {
			Key = "a",
			ByteKey = 20,
		},
		Direction = Vector3.new(-1, 0, 0),
		State = false,
		LastDown = 0
	},
	Right = {
		Keys = {
			Key = "d",
			ByteKey = 19,
		},
		Direction = Vector3.new(1, 0, 0),
		State = false,
		LastDown = 0
	}
}

ShotDamage = 90

IsPlayingDrive = false
LastDrivingTime = 0

ReloadTime = 1
LastShotTime = 0

ToolCurrentlyEquipped = false

NoteGui = Create("ScreenGui"){
	Create("ImageLabel"){
		Name = "DriveNote",
		Position = UDim2.new(0.5, (-128 + 8), 1, -200),
		Size = UDim2.new(0, 128, 0, 64),
		BackgroundTransparency = 1,
		Image = "http://www.roblox.com/asset/?id=82229919",
		Visible = false,
	},
	Create("ImageLabel"){
		Name = "FireNote",
		Position = UDim2.new(0.5, 0-8, 1, -200),
		Size = UDim2.new(0, 128, 0, 64),
		BackgroundTransparency = 1,
		Image = "http://www.roblox.com/asset/?id=82071115",
		Visible = false,
	},
	Create("ImageLabel"){
		Name = "CreateNote",
		Position = UDim2.new(0.5, -64, 1, -200),
		Size = UDim2.new(0, 128, 0, 64),
		BackgroundTransparency = 1,
		Image = "http://www.roblox.com/asset/?id=82071122",
		Visible = true,
	},
}

CastInfo = {
	{
		Name = "FrontRight",
		Ahead = CFrame.new(1.2, 2.3, 0.3),
		AheadDesired = 1.24,
		Stand = CFrame.new(1.2, 1.1, 0),
		StandDesired = 0.94,
	},
	{
		Name = "FrontLeft",
		Ahead = CFrame.new(-1.2, 2.3, 0.3),
		AheadDesired = 1.24,
		Stand = CFrame.new(-1.2, 1.1, 0),
		StandDesired = 0.94,
	},
	{
		Name = "BackRight",
		Ahead = CFrame.new(1.2, -2.3, 0.3),
		AheadDesired = 1.24,
		Stand = CFrame.new(1.2, -1.6, 0),
		StandDesired = 0.94,
	}, 
	{
		Name = "BackLeft",
		Ahead = CFrame.new(-1.2, -2.3, 0.3),
		AheadDesired = 1.24,
		Stand = CFrame.new(-1.2, -1.6, 0),
		StandDesired = 0.94,
	},
}

for _, dat in pairs(CastInfo) do
	dat.LocalAxis = dat.Stand.p:Cross(Vector3.new(0, 0, 1)).unit
	dat.AheadLength = dat.Ahead.p.magnitude
	dat.StandLength = dat.Stand.p.magnitude
end

Tool.Grip = CFrame.new(-0.191770241, 0.0683477223, -0.607085466, -0.87758249, 0, -0.479425609, -0.420735568, 0.47942549, 0.770151138, 0.229848862, 0.87758261, -0.420735419)
Mesh.MeshId = "http://www.roblox.com/asset/?id=81616133"

ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool

ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool

Handle.Transparency = 0
Tool.Enabled = true

ServerControl.OnServerInvoke = (function(player, Mode, Value)
	if player == Player and CheckIfAlive() then
		if Mode == "MouseClick" and Value.Down then
			--Activated()
		elseif Mode == "MouseMove" and not CheckIfTankAlive() then
			local MousePosition = InvokeClient("MousePosition")
			if (Torso.Position - MousePosition).magnitude < 20 then
				InvokeClient("SetMouseIcon", "http://www.roblox.com/asset/?id=82230945")
			else
				InvokeClient("SetMouseIcon", "http://www.roblox.com/asset/?id=82071072")
			end
		elseif Mode == "KeyPress" then
			local Key = Value.Key
			local ByteKey = string.byte(Key)
			local Down = Value.Down
			if Down then
				local DirectionKeyPressed = false
				for i, v in pairs(Directions) do
					for ii, vv in pairs(v.Keys) do
						if ((ii == "Key" and vv == Key) or (ii == "ByteKey" and vv == ByteKey)) then
							Directions[i].State = true
							Directions[i].LastDown = 0
							DirectionKeyPressed = true
						end
					end
				end
				if ToolCurrentlyEquipped and CheckIfAlive() and CheckIfTankAlive() then
					if DirectionKeyPressed and not IsPlayingDrive then
						IsPlayingDrive = true
						StartSound:Play()
						DriveSound:Play()
						IdleSound:Stop()
					else
					end
				end
			else
				for i, v in pairs(Directions) do
					for ii, vv in pairs(v.Keys) do
						if ((ii == "Key" and vv == Key) or (ii == "ByteKey" and vv == ByteKey)) then
							Directions[i].State = false
							Directions[i].LastDown = tick()
						end
					end
				end
				if Tank and IsPlayingDrive then
					local IsDriving = false
					for i, v in pairs(Directions) do
						if v.State then
							IsDriving = true
						end
					end
					if not IsDriving then
						IsPlayingDrive = false
						LastDrivingTime = tick()
						DriveSound:Stop()
						IdleSound:Play()
					end
				end
			end
		end
	end
end)

function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end

function TopVector(cframe)
	local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components()
	return Vector3.new(R01, R11, R21)
end

function BackVector(cframe)
	local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components()
	return Vector3.new(R02, R12, R22)
end

function RightVector(cframe)
	local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components()
	return Vector3.new(R00, R10, R20)
end

function CFrameFromTopBack(at, top, back)
	local Right = top:Cross(back)
	return CFrame.new(
		at.x, at.y, at.z,
		Right.x, top.x, back.x,
		Right.y, top.y, back.y,
		Right.z, top.z, back.z
	)
end

function CreateTank()
	local Body = Create("Part"){
		Name = "Torso",
		FormFactor = "Custom",
		Size = Vector3.new(2.8, 4.25, 1.75),
		Create("SpecialMesh"){
			Scale = Vector3.new(2.5, 2, 2.5),
			MeshId = "http://www.roblox.com/asset/?id=81616058",
			TextureId = "http://www.roblox.com/asset/?id=81616111",
		},
		Create("BodyGyro"){
			maxTorque = Vector3.new(math.huge, math.huge, math.huge),
			cframe = CFrame.new(0, 0, 0),
		},
		Create("Sound"){
			Name = "FireSound",
			SoundId = "http://www.roblox.com/asset/?id=81116734",
		},
		Create("Sound"){
			Name = "ExplodeSound",
			SoundId = "http://www.roblox.com/asset/?id=81116747",
		},
		Create("Sound"){
			Name = "IdleSound",
			SoundId = "http://www.roblox.com/asset/?id=82229695",
			Looped = true,
			Pitch = 0.6,
			Volume = 0.2,
		},
		Create("Sound"){
			Name = "StartSound",
			SoundId = "http://www.roblox.com/asset/?id=82229695",
			Pitch = 0.8,
			Volume = 1.0,
		},
		Create("Sound"){
			Name = "DriveSound",
			SoundId = "http://www.roblox.com/asset/?id=82229584",
			Pitch = 1.5,
			Volume = 1.0,
			Looped = true,
		},
	}
	
	BodyGyro = Body:FindFirstChild("BodyGyro")
	FireSound = Body:FindFirstChild("FireSound")
	ExplodeSound = Body:FindFirstChild("ExplodeSound")
	IdleSound = Body:FindFirstChild("IdleSound")
	StartSound = Body:FindFirstChild("StartSound")
	DriveSound = Body:FindFirstChild("DriveSound")
	
	local Turret = Create("Part"){
		Name = "Head",
		FormFactor = "Custom",
		Size = Vector3.new(2.4, 1.6, 0.7),
		CanCollide = false,
		Create("SpecialMesh"){
			Scale = Vector3.new(2.5, 2, 3.5),
			MeshId = "http://www.roblox.com/asset/?id=81616087",
			TextureId = "http://www.roblox.com/asset/?id=81616111",
		},
	}
	
	local Cannon = Create("Part"){
		Name = "Cannon",
		FormFactor = "Custom",
		Size = Vector3.new(0.4, 0.4, 0.4),
		Create("SpecialMesh"){
			Scale = Vector3.new(5, 2, 5),
			MeshId = "http://www.roblox.com/asset/?id=81616091",
			TextureId = "http://www.roblox.com/asset/?id=81616111",
		},
	}
	
	local Humanoid = Create("Humanoid"){
		PlatformStand = true,
	}
	
	local TurretAttach = Create("Weld"){
		Name = "Neck",
		Parent = Body,
		Part0 = Body,
		Part1 = Turret,
		C0 = CFrame.new(0, 0, 0.5),
		C1 = CFrame.new(0, 0, -0.4),
	}
	
	local CannonAttach = Create("Weld"){
		Name = "CannonAttach",
		Parent = Turret,
		Part0 = Turret,
		Part1 = Cannon,
		C0 = CFrame.new(0, 0.875, -0.2),
		C1 = CFrame.new(0, 0.1, 0),
	}
	
	local Model = Create("Model"){
		Name = "Tank",
	}
	
	Body.Parent = Model
	Turret.Parent = Model
	Cannon.Parent = Model
	Humanoid.Parent = Model
	Humanoid.MaxHealth = 500
	Humanoid.Health = Humanoid.MaxHealth

	return {
		Model = Model,
		Body = Body,
		BodyGyro = BodyGyro,
		Turret = Turret,
		Cannon = Cannon,
		TurretAttach = TurretAttach,
		CannonAttach = CannonAttach,
		Humanoid = Humanoid,
	}
	
end

function DoCastDown(Offset, Dir)
	Dir = (Dir or Vector3.new(0, -1, 0))
	local CastFrom = ((Tank.Body.CFrame * Offset).p - Dir * 2.5)
	
	local ray = Ray.new(CastFrom, Dir * 999)
	local Part, at = game:GetService("Workspace"):FindPartOnRay(ray, Tank.Model)
	if Part and (not Part.CanCollide or Part.Transparency == 1) then
		local Parts = {Tank.Body, Tank.Turret, Tank.Cannon}
		while Part and (not Part.CanCollide or Part.Transparency == 1) do
			Parts[#Parts + 1] = Part
			Part, at = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(ray, Parts)
		end
	end
	
	return Part, at, ((CastFrom - at).magnitude - 2.5)
end

function Clamp(n, min, max)
	return math.max(math.min(max, n), min)
end

function Sign(n)
	return (((n >= 0) and 1) or -1)
end

function CheckIfTankAlive()
	return (Tank and Tank.Model and Tank.Model.Parent and Tank.Body and Tank.Body.Parent and Tank.Turret and Tank.Turret.Parent and Tank.Cannon and Tank.Cannon.Parent and Tank.Humanoid and Tank.Humanoid.Parent and Tank.Humanoid.Health > 0)
end

function EnableSteering()
	local LastTime = tick()
	local LastTimeInAir = 0
	local LastVelocity = 0
	local DesiredHeading = Vector3.new()
	local IsOnGround = false
	local TurnSpeed = 1.8 -- rad / sec
	local MoveSpeed = 11.0 -- stud / sec

	local CurrentlyEquipped = true
	local Connected = true

	for i, v in pairs({TankControl, ToolUnequipped}) do
		if v then
			v:disconnect()
		end
	end
	
	ToolUnequipped = Tool.Unequipped:connect(function()
		CurrentlyEquipped = false
	end)
	
	TankControl = RunService.Heartbeat:connect(function()

		if not CurrentlyEquipped or not CheckIfAlive() or not CheckIfTankAlive() then
			Connected = false
			for i, v in pairs({TankControl, ToolUnequipped}) do
				if v then
					v:disconnect()
				end
			end
		end

		if Connected then
			local t = tick()
			local dt = (t - LastTime)
			LastTime = t
			
			local MousePosition = InvokeClient("MousePosition")
			
			if (Tank.Turret.Position - MousePosition).magnitude < 140 then
				InvokeClient("SetMouseIcon", "http://www.roblox.com/asset/?id=82071097")
			else
				InvokeClient("SetMouseIcon", "http://www.roblox.com/asset/?id=82071109")
			end
			
			local _, _, DistOffGround = DoCastDown(CFrame.new())
			DistOffGround = (DistOffGround - 0.94)
			if DistOffGround > 3 then
				if IsOnGround then
					IsOnGround = false
					BodyGyro.maxTorque = Vector3.new(0, 0, 0)
				end
				LastTimeInAir = t
				
				DriveSound.Pitch = 1.8
				
			elseif (t - LastTimeInAir) > 2 then
				
				DriveSound.Pitch = (1.2 + 0.6 * LastVelocity)
				
				if not IsOnGround then
					IsOnGround = true
					BodyGyro.maxTorque = Vector3.new(math.huge, math.huge, math.huge)
				end
				
				local BodyLook = TopVector(Tank.Body.CFrame)
				DesiredHeading = Vector3.new(BodyLook.x, 0, BodyLook.z).unit
				
				local TankSavedPositionHack = Tank.Body.CFrame
				local TurretToHitVec = (MousePosition - Tank.Turret.Position)
				local DistToHit = TurretToHitVec.magnitude
				local RotAxis = TurretToHitVec:Cross(TurretToHitVec - Vector3.new(0, TurretToHitVec.y, 0)).unit
				if TurretToHitVec.y > 0 then
					RotAxis = -RotAxis
				end
				local TurretToHit = (CFrame.fromAxisAngle(RotAxis, math.min(1, DistToHit / 140) * math.pi / 3.5) * TurretToHitVec.unit)
				local SwivelPlaneNormal = Tank.Body.CFrame.lookVector
				local TurretDir = (TurretToHit - SwivelPlaneNormal * TurretToHit:Dot(SwivelPlaneNormal)).unit
				local DesiredTurretCF = CFrameFromTopBack(Tank.Turret.Position, TurretDir, -SwivelPlaneNormal) * CFrame.Angles(0, 0.01, 0)
				Tank.Body.CFrame = TankSavedPositionHack
				Tank.TurretAttach.C1 = DesiredTurretCF:inverse() * Tank.Body.CFrame * CFrame.new(0, 0, 0.5)
				
				local DesiredCannonCF = CFrameFromTopBack((Tank.Turret.CFrame * CFrame.new(0, 1.125, -0.2)).p, TurretToHit, TurretToHit:Cross(RightVector(DesiredTurretCF)))
				--[[if (t - LastShotTime) < 1 then
					local Elapsed = (t - LastShotTime)
					if Elapsed < 0.1 then
						DesiredCannonCF = DesiredCannonCF * CFrame.new(0, -((Elapsed / 0.1) * 0.8), 0)
					else
						DesiredCannonCF = DesiredCannonCF * CFrame.new(0, -((1 - ((Elapsed - 0.1) / 0.9)) * 0.8),0)
					end
				end]]
				Tank.CannonAttach.C1 = DesiredCannonCF:inverse() * Tank.Turret.CFrame * CFrame.new(0, 1.125, -0.2)
				Tank.Body.CFrame = TankSavedPositionHack
				
				local CoordinateFrame = InvokeClient("GetCamera", {Property = "CoordinateFrame"})
				local CamLook = CoordinateFrame.lookVector
				local CamDir = Vector3.new(CamLook.x, 0, CamLook.z).unit
				local CamPerpDir = CamDir:Cross(Vector3.new(0, 1, 0))
				
				local MoveDirs = Vector3.new()
				local function Decay(v)
					return (1 - math.sqrt(1 - v))
				end
				
				for i, v in pairs(Directions) do
					if Directions[i].State then
						MoveDirs = (MoveDirs + v.Direction)
					end
					local Delay = 0.8
					if v.Direction.X ~= 0 then
						Delay = 0.4
					end
					if (t - Directions[i].LastDown) < Delay then
						MoveDirs = (MoveDirs + v.Direction * Decay(Delay - (t - Directions[i].LastDown)))
					end
				end
				local KeyHeading = (CamDir * MoveDirs.y + CamPerpDir * MoveDirs.x)
				
				local SpeedFactor = KeyHeading:Dot(DesiredHeading)
				local TurnFactor
				if KeyHeading.magnitude > 0 then
					TurnFactor = -KeyHeading.unit:Cross(DesiredHeading).y
				else
					TurnFactor = 0
				end
				
				LastVelocity = math.abs(SpeedFactor)
				
				local TankLevelCF = CFrameFromTopBack(Tank.Body.Position, DesiredHeading, Vector3.new(0, 1, 0))
				if TurnFactor ~= 0 or SpeedFactor ~= 0 then
					local TankCFrame = TankLevelCF * CFrame.Angles(0, 0, (TurnFactor * TurnSpeed * dt)) * CFrame.new(0, (SpeedFactor * MoveSpeed * dt), 0)
					local PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22 = TankCFrame:components()
					if tostring(PX) ~= "-1.#IND" and tostring(PY) ~= "-1.#IND" and tostring(PZ) ~= "-1.#IND" then
						Tank.Body.CFrame = CFrame.new(PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22)
					end
				else
					local PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22 = TankLevelCF:components()
					if tostring(PX) ~= "-1.#IND" and tostring(PY) ~= "-1.#IND" and tostring(PZ) ~= "-1.#IND" then
						Tank.Body.CFrame = CFrame.new(PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22)
					end
				end
				
				local AvrDisp = 0
				local NumDisps = 0
				for _, Cast in pairs(CastInfo) do
					local _, _, aheadH = DoCastDown(Cast.Ahead)
					local _, _, standH = DoCastDown(Cast.Stand)
					Cast.AheadH = (aheadH - Cast.AheadDesired)
					Cast.StandH = (standH - Cast.StandDesired)
					if Cast.AheadH < 3 then
						AvrDisp = (AvrDisp + Cast.AheadH)
						NumDisps = (NumDisps + 1)
					end
				end
				AvrDisp = ((NumDisps > 0) and (AvrDisp / NumDisps) or 0)
				local tankRot = Tank.Body.CFrame - Tank.Body.CFrame.p
				local RotAmountX = 0
				local RotAmountY = 0
				local NumRots = 0
				for _, Cast in pairs(CastInfo) do
					local Which = nil
					if Cast.AheadH > 3 and Cast.StandH > 3 then
					elseif Cast.AheadH > 3 then
						Which = true
					elseif Cast.StandH > 3 then
						Which = false
					else
						Which = (Cast.StandH < Cast.AheadH)
					end
					if Which ~= nil then
						local h, distOut
						if Which then
							h = Cast.StandH
							distOut = Cast.StandLength
						else
							h = Cast.AheadH
							distOut = Cast.AheadLength
						end
						h = (h - AvrDisp)
						local theta = -math.atan(h / distOut)
						RotAmountX = (RotAmountX + theta * Cast.LocalAxis.x)
						RotAmountY = (RotAmountY + theta * Cast.LocalAxis.y)
						NumRots = (NumRots + 1)
					end
				end
				
				Tank.BodyGyro.cframe = CFrame.new(0, -AvrDisp, 0) * Tank.Body.CFrame * CFrame.Angles((RotAmountX / NumRots * 2), 0, 0) * CFrame.Angles(0, (RotAmountY / NumRots * 2), 0)
				
				local _, _, RightFudge = DoCastDown(CFrame.new(1.2, 0, 0))
				local _, _, LeftFudge = DoCastDown(CFrame.new(-1.2, 0, 0))
				RightFudge = ((RightFudge - 0.94) / math.cos(RotAmountX / NumRots * 2))
				LeftFudge = ((LeftFudge - 0.94) / math.cos(RotAmountX / NumRots * 2))
				if RightFudge < 1 and LeftFudge < 1 then
					Tank.BodyGyro.cframe = CFrame.new(0, -0.5 * (RightFudge + LeftFudge), 0) * Tank.Body.CFrame
				elseif RightFudge < 1 then
					Tank.BodyGyro.cframe = CFrame.new(0, -RightFudge, 0) * Tank.Body.CFrame
				elseif LeftFudge < 1 then
					Tank.BodyGyro.cframe = CFrame.new(0, -LeftFudge, 0) * Tank.Body.CFrame
				end
				
				local DesiredLen = 0.6
				local CastDir = TopVector(Tank.Body.CFrame)
				local Parta, ata, dista = DoCastDown(CFrame.new(1.2, 1.5, 0.5), CastDir)
				local Partb, atb, distb = DoCastDown(CFrame.new(-1.2, 1.5, 0.5), CastDir)
				local smallerGap = (math.min(dista, distb) - DesiredLen)
				if smallerGap < 0 then
					Tank.Body.CFrame = Tank.Body.CFrame * CFrame.new(0, smallerGap, 0)
				end
				
			else
				--falling
			end
		end
	end)
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function Fire(Origin, TargetPosition, Direction)
	local Projectile = Instance.new("Part")
	Projectile.Name = "Projectile"
	Projectile.Material = Enum.Material.Plastic
	Projectile.Shape = Enum.PartType.Block
	Projectile.TopSurface = Enum.SurfaceType.Smooth
	Projectile.BottomSurface = Enum.SurfaceType.Smooth
	Projectile.FormFactor = Enum.FormFactor.Custom
	Projectile.CFrame = CFrame.new(Origin)
	Projectile.Shape = Enum.PartType.Ball
	Projectile.Size = Vector3.new(1, 1, 1)
	local BodyPosition = Create("BodyPosition"){
		maxForce = Vector3.new(10000, 10000, 10000),
		P = 30000,
		Parent = Projectile,
	}
	local ExplodeSound = Create("Sound"){
		SoundId = "http://www.roblox.com/asset/?id=81116747",
		Parent = Projectile,
	}	
	local TotalDist = (TargetPosition - Origin).magnitude
	local Speed = 80 --studs/sec
	local FlightTime = (TotalDist / Speed)
	local Exploded = false
	local function Explode()
		if Exploded then
			return
		end
		Exploded = true
		Projectile.Transparency = 1
		Projectile.Anchored = true
		local Explosion = Create("Explosion"){
			BlastPressure = 0,
			BlastRadius = 12,
			Position = Projectile.Position,
		}
		local HitHumanoids = {}
		Explosion.Hit:connect(function(Hit)
			if not Hit or not Hit.Parent then
				return
			end
			local character = Hit.Parent
			local humanoid = character:FindFirstChild("Humanoid")
			if humanoid and not HitHumanoids[humanoid] and humanoid ~= Tank.Humanoid and humanoid ~= Humanoid then
				HitHumanoids[humanoid] = true
				UntagHumanoid(humanoid)
				TagHumanoid(humanoid, Player)
				humanoid:TakeDamage(ShotDamage)
			end
		end)
		Explosion.Parent = game:GetService("Workspace")
		ExplodeSound:Play()
		Debris:AddItem(Projectile, 2)
		Debris:AddItem(Explosion, 2)
	end

	Projectile.Touched:connect(function(Hit)
		if not Hit or not Hit.Parent then
			return
		end
		local character = Hit.Parent
		if character == Tank.Model then
			return
		end
		Explode()
	end)
	
	Debris:AddItem(Projectile, 5)
	Projectile.Parent = game:GetService("Workspace")	
	
	local AheadVector = (Direction.unit * TotalDist)
	local FlightVector = (TargetPosition - Origin)
	
	--keep flying
	Projectile.Anchored = false
	for t = 0, FlightTime, 0.033 do
		if Exploded then
			break
		end
		local f = (t / FlightTime)
		--
		BodyPosition.position = (Origin + ((AheadVector * f) * ( 1 - f) + (FlightVector * f) * f))
		--
		wait(0.03)
	end
	BodyPosition.position = TargetPosition
	Spawn(function()
		while Projectile and Projectile.Parent and (Projectile.Position - TargetPosition).magnitude > 1 do
			wait()
		end
		Explode()
	end)

end

function Activated()
	if not CheckIfAlive() then
		return
	end
	local MousePosition = InvokeClient("MousePosition")
	if Tank and Tank.Model and Tank.Model.Parent then
		if (tick() - LastShotTime) > ReloadTime then
			local Origin = (Tank.Cannon.CFrame * CFrame.new(0, 3, 0)).p
			local Direction = TopVector(Tank.Cannon.CFrame)
			if (MousePosition - Origin).magnitude < 140 then
				LastShotTime = tick()
				FireSound:Play()
				Fire(Origin, MousePosition, Direction)
			end
		end
	elseif (Torso.Position - MousePosition).magnitude < 20 then
		Tank = CreateTank()
		
		local ScriptName = (Player.Name .. Remover.Name)
		local RemoverClone = game:GetService("Workspace"):FindFirstChild(ScriptName)
		if RemoverClone then
			RemoverClone:Destroy()
		end
		RemoverClone = Remover:Clone()
		RemoverClone.Name = ScriptName
		local CreatorValue = Instance.new("ObjectValue")
		CreatorValue.Name = "Creator"
		CreatorValue.Value = Player
		CreatorValue.Parent = RemoverClone
		local ToolValue = Instance.new("ObjectValue")
		ToolValue.Name = "Tool"
		ToolValue.Value = Tool
		ToolValue.Parent = RemoverClone
		local ModelValue = Instance.new("ObjectValue")
		ModelValue.Name = "Model"
		ModelValue.Value = Tank.Model
		ModelValue.Parent = RemoverClone
		RemoverClone.Disabled = false
		RemoverClone.Parent = game:GetService("Workspace")
		
		Tank.Model.Parent = game:GetService("Workspace")
		
		local TankCFrame = CFrameFromTopBack((MousePosition + Vector3.new(0, 1.8, 0)), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0))
		Tank.Body.CFrame = TankCFrame
		Tank.BodyGyro.cframe = TankCFrame 
			
		InvokeClient("SetCamera", {Property = "CameraSubject", Value = Tank.Model})
		InvokeClient("SetCamera", {Property = "CameraType", Value = Enum.CameraType.Track})
		
		IdleSound:Play()
		
		Humanoid.WalkSpeed = 0

		if NoteGuiClone and NoteGuiClone.Parent then
			NoteGuiClone.CreateNote.Visible = false
			NoteGuiClone.DriveNote.Visible = true
			NoteGuiClone.FireNote.Visible = true
		end
		
		Tank.Humanoid.Died:connect(function()
			game.Debris:AddItem(Tank.Model, 2)
			Tank.Model:BreakJoints()
			Tank = nil
			InvokeClient("SetCamera", {Property = "CameraSubject", Value = Character})
			InvokeClient("SetCamera", {Property = "CameraType", Value = Enum.CameraType.Custom})
			if NoteGuiClone and NoteGuiClone.Parent then
				NoteGuiClone.CreateNote.Visible = true
				NoteGuiClone.DriveNote.Visible = false
				NoteGuiClone.FireNote.Visible = false
			end
			InvokeClient("DisableJump", false)
			Humanoid.WalkSpeed = 16
		end)
		
		Spawn(function()
			EnableSteering()
		end)
				
	end
end

function CheckIfAlive()
	return (((Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end

function Equipped()
	
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	PlayerGui = Player:FindFirstChild("PlayerGui")
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	if not CheckIfAlive() then
		return
	end
	
	ToolCurrentlyEquipped = true
	
	if PlayerGui then
		NoteGuiClone = NoteGui:Clone()
		NoteGuiClone.CreateNote.Visible = true
		NoteGuiClone.DriveNote.Visible = false
		NoteGuiClone.FireNote.Visible = false
		NoteGuiClone.Parent = PlayerGui
	end
		
end

function Unequipped()
	if NoteGuiClone and NoteGuiClone.Parent then
		NoteGuiClone:Destroy()
	end
	if Tank and Tank.Model and Tank.Model.Parent then
		Tank.Model:Destroy()
	end
	for i, v in pairs({TankControl, ToolUnequipped}) do
		if v then
			v:disconnect()
		end
	end
	IsPlayingDrive = false
	LastDrivingTime = 0
	InvokeClient("SetCamera", {Property = "CameraType", Value = Enum.CameraType.Custom})
	InvokeClient("SetCamera", {Property = "CameraSubject", Value = Character})
	InvokeClient("PreventJump", false)
	if Humanoid and Humanoid.Parent then
		Humanoid.WalkSpeed = 16
	end
	ToolCurrentlyEquipped = false
end

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX7BA02ADEFEF644FDAFC025195318B349">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Remover</string>
					<string name="ScriptGuid">{ADA72E86-B2A6-48C8-B03B-B69B586119EB}</string>
					<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Debris = game:GetService("Debris")

Creator = script:FindFirstChild("Creator")
Tool = script:FindFirstChild("Tool")
Model = script:WaitForChild("Model")

function DestroyModel()
	if Model and Model.Parent then
		Debris:AddItem(Model, 2)
	end
	Debris:AddItem(script, 2)
end

if not Creator or not Creator.Value or not Creator.Value:IsA("Player") or not Creator.Value.Parent or not Tool or not Tool.Value or not Tool.Value.Parent or not Model or not Model.Value then
	DestroyModel()
	return
end

Creator = Creator.Value
Tool = Tool.Value
Model = Model.Value

Character = Creator.Character
if not Character then
	DestroyModel()
	return
end

Creator.Changed:connect(function(Property)
	if Property == "Parent" and not Creator.Parent then
		DestroyModel()
	end
end)

Character.Changed:connect(function(Property)
	if Property == "Parent" and not Character.Parent then
		DestroyModel()
	end
end)

Tool.Changed:connect(function(Property)
	if Property == "Parent" then
		DestroyModel()
	end
end)

Model.Changed:connect(function(Property)
	if Property == "Parent" and not Model.Parent then
		DestroyModel()
	end
end)]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBXF43157CC53C64F4EBD9029F0671655BE">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<string name="ScriptGuid">{8637D5C7-ECCE-4995-A0DD-79F9F6ADE107}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
ContentProvider = game:GetService("ContentProvider")
RunService = game:GetService("RunService")

Camera = game:GetService("Workspace").CurrentCamera

Animations = {}

ServerControl = Tool:WaitForChild("ServerControl")
ClientControl = Tool:WaitForChild("ClientControl")

Equipped = false

ClientControl.OnClientInvoke = (function(Mode, Value)
	if Mode == "PlayAnimation" and Value and Equipped and Humanoid then
		SetAnimation("PlayAnimation", Value)
	elseif Mode == "StopAnimation" and Value then
		SetAnimation("StopAnimation", Value)
	elseif Mode == "Preload" and Value then
		ContentProvider:Preload(Value)
	elseif Mode == "PlaySound" and Value then
		Value:Play()
	elseif Mode == "StopSound" and Value then
		Value:Stop()
	elseif Mode == "MousePosition" then
		return PlayerMouse.Hit.p
	elseif Mode == "DisableJump" then
		DisableJump(Value)
	elseif Mode == "SetMouseIcon" and Value then
		PlayerMouse.Icon = Value
	elseif Mode == "SetLocalTransparencyModifier" and Value then
		pcall(function()
			Value.Object.LocalTransparencyModifier = Value.Transparency
		end)
	elseif Mode == "GetCamera" and Value then
		local PropertyValue = nil
		if Value.Property then
			pcall(function()
				PropertyValue = Camera[Value.Property]
			end)
		end
		return PropertyValue
	elseif Mode == "SetCamera" and Value then
		if Value.Property and Value.Value then
			pcall(function()
				Camera[Value.Property] = Value.Value
			end)
		end
	elseif Mode == "SetMouseSensitivity" and Value then
		if Value.Sensitivity == 1 then
			if MouseSensivityConnection then
				MouseSensivityConnection:disconnect()
			end
		else
			SetMouseSensitivity(Value.Sensitivity)
		end
	end
end)

function InvokeServer(Mode, Value)
	pcall(function()
		local ServerReturn = ServerControl:InvokeServer(Mode, Value)
		return ServerReturn
	end)
end

function SetAnimation(Mode, Value)
	if Mode == "PlayAnimation" and Value and Equipped and Humanoid then
		for i, v in pairs(Animations) do
			if v.Animation == Value.Animation then
				v.AnimationTrack:Stop()
				table.remove(Animations, i)
			end
		end
		local AnimationTrack = Humanoid:LoadAnimation(Value.Animation)
		table.insert(Animations, {Animation = Value.Animation, AnimationTrack = AnimationTrack})
		AnimationTrack:Play(Value.FadeTime, Value.Weight, Value.Speed)
	elseif Mode == "StopAnimation" and Value then
		for i, v in pairs(Animations) do
			if v.Animation == Value.Animation then
				v.AnimationTrack:Stop()
				table.remove(Animations, i)
			end
		end
	end
end

function DisableJump(Boolean)
	if PreventJump then
		PreventJump:disconnect()
	end
	if Boolean then
		PreventJump = Humanoid.Changed:connect(function(Property)
			if Property ==  "Jump" then
				Humanoid.Jump = false
			end
		end)
	end
end

function SetMouseSensitivity(Sensitivity)

	if MouseSensivityConnection then
		MouseSensivityConnection:disconnect()
	end	
	
	local function EulerAnglesYX(cframe)
		local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components(cframe)
		return -math.asin(R12), ((math.abs(R12) > 0.99999 and -math.atan2(-R20, R00)) or -math.atan2(-R02, R22))
	end
	
	local DirectionX, DirectionY = EulerAnglesYX(Camera.CoordinateFrame)
	
	local function UpdateSensitivity()
		local CFrameX, CFrameY = EulerAnglesYX(Camera.CoordinateFrame)
		DirectionX = (DirectionX * (1 - Sensitivity) + (CFrameX + (math.pi * 2) * math.floor((DirectionX - CFrameX) / (math.pi * 2) + 0.5)) * Sensitivity)
		DirectionY = (DirectionY * (1 - Sensitivity) + (CFrameY + (math.pi * 2) * math.floor((DirectionY - CFrameY) / (math.pi * 2) + 0.5)) * Sensitivity)
		Camera.CoordinateFrame = CFrame.Angles(0, DirectionY, 0) * CFrame.Angles(DirectionX, 0, 0) * CFrame.new(0, 0, 0.5) + Camera.Focus.p
	end
	
	MouseSensivityConnection = RunService.RenderStepped:connect(UpdateSensitivity)
	
end

function CheckIfAlive()
	return (Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Equipped = true
	if not CheckIfAlive() then
		return
	end
	PlayerMouse = Player:GetMouse()
	Mouse.Button1Down:connect(function()
		InvokeServer("MouseClick", {Down = true})
	end)
	Mouse.Move:connect(function()
		InvokeServer("MouseMove", {Target = Mouse.Target, Position = Mouse.Hit.p})
	end)
	Mouse.KeyDown:connect(function(Key)
		InvokeServer("KeyPress", {Key = Key, Down = true})
	end)
	Mouse.KeyUp:connect(function(Key)
		InvokeServer("KeyPress", {Key = Key, Down = false})
	end)
	Mouse.WheelForward:connect(function()
		InvokeServer("WheelMoved", {Forward = true})
	end)
	Mouse.WheelBackward:connect(function()
		InvokeServer("WheelMoved", {Forward = false})
	end)
end

function Unequipped()
	Equipped = false
	for i, v in pairs(Animations) do
		if v and v.AnimationTrack then
			v.AnimationTrack:Stop()
		end
	end
	for i, v in pairs({PreventJump, MouseSensivityConnection}) do
		if v then
			v:disconnect()
		end
	end
	PlayerMouse.Icon = ""
	Animations = {}
end

Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX51E73A07492C48DD9367DCB544043A21">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<string name="ScriptGuid">{3D479620-35EE-4EEE-88A8-3AEF9491724A}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent

Players = game:GetService("Players")

Player = Players.LocalPlayer

Icons = {
	Normal = "rbxasset://textures/GunCursor.png",
	Reloading = "rbxasset://textures/GunWaitCursor.png"
}

ToolEquipped = false

function UpdateIcon()
	if Mouse and ToolEquipped then
		Mouse.Icon = (((Tool.Enabled and (Mouse.Icon == Icons.Reloading or Mouse.Icon == "")) and Icons.Normal) or ((not Tool.Enabled and (Mouse.Icon == Icons.Normal or Mouse.Icon == "")) and Icons.Reloading) or Mouse.Icon)
	end
end

function Equipped()
	ToolEquipped = true
	Mouse = Player:GetMouse()
	MouseChanged = Mouse.Changed:connect(Changed)
	UpdateIcon()
end

function Unequipped()
	ToolEquipped = false
	Mouse.Icon = ""
	if MouseChanged then
		MouseChanged:disconnect()
	end
end

function Changed(Property)
	if Property == "Enabled" or (Property == "Icon" and Mouse.Icon == "") then
		UpdateIcon()
	end
end

Tool.Changed:connect(Changed)

Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX2B31BAA7FD5344E5A101F1B2E8E9DDFB">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-0.007853508</X>
					<Y>17.3634109</Y>
					<Z>22.1025734</Z>
					<R00>-0.66572535</R00>
					<R01>-0.0181267522</R01>
					<R02>0.745976746</R02>
					<R10>-1.3737448e-14</R10>
					<R11>0.999704897</R11>
					<R12>0.0242921822</R12>
					<R20>-0.746196926</R20>
					<R21>0.016171921</R21>
					<R22>-0.665528893</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<int name="CollisionGroupId">0</int>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>1.20000005</Y>
					<Z>6</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX4669FF5ACBA5446BABD6CE5F9565E274">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=82934522</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=81616111</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Attachment" referent="RBXE83CB1E533114830BDEF332079B94358">
				<Properties>
					<CoordinateFrame name="CFrame">
						<X>-1.67405233e-07</X>
						<Y>-0.850000024</Y>
						<Z>-1.9161962e-07</Z>
						<R00>0</R00>
						<R01>1</R01>
						<R02>-0</R02>
						<R10>-1</R10>
						<R11>0</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">RightGripAttachment</string>
					<bool name="Visible">false</bool>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>